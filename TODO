This file is formatted for Emacs' org-mode (see http://www.orgmode.org)
To view it properly, open it in Emacs 23.x and type:  M-x org-mode
* DONE Fix WAVE/MP3 formats to support MP3 audio in a WAVE container
  Instead of WaveAudio generating a nasty "compression not supported" error,
  its is_type() classmethod should return False.
  And, MP3Audio's is_type() classmethod should check for MP3 compressed
  RIFF WAVE containers.
  This isn't likely to mess up decoding, but may confuse ID3 tagging.
* DONE Allow file template to be specified on the command line
  When making new files with track2track, cd2track, etc.
* DONE Update the website with the latest documentation
* DONE Allow a unified %(album_track_number)s file template field
  If there's no album number, it's simply 2 digits of track number.
  Otherwise, it's a combination of the two fields.
  For example, album_number = 2 and track_number = 13 results in
  "213" for a value.
* DONE Update trackcat to take a cuesheet argument when outputting FLACs
  Thus, one can perform:
  trackcat --cuesheet=file.cue file1.wav file2.wav file3.wav -t flac -o cd.flac
  which will embed "file.cue" into "cd.flac" using metaflac.
  Though no other format I'm aware of supports this kind of cuesheet handling,
  being able to easily build solid disc images of a single FLAC file
  is much of the reason for trackcat/tracksplit.
* DONE Don't remove undone tracklint entries from its undo DB
  Since its checksum will change anyway and no longer match,
  explicitly removing the entry is no longer necessary
* DONE Support FLAC padding
  If changes to FLAC metadata are small enough, write over the
  padding (if present) rather than rewrite the whole file - like metaflac.
  This approach should speed up tagging considerably.
* DONE Fix image support in ID3v2
  Very large images can take a very long time to load.
* DONE Fix programs to key on album number and track number
  Certain programs, such as trackcmp, work on tracks across two directories
  and key on track number to determine which to compare to which.
  These need to be updated to use both track number and album number.
* DONE Adjust wave conversions to use album number, if present
  For example, converting track_number 15 and album_number 2 to WAVE
  should make a file "track215.cdda.wav" which then properly converts
  back to track_number 15 and album_number 2 if read.
* DONE Improve XMCD handling
  Support for XMCD files often breaks down if one or more tracks
  are missing.
  In some cases, there's no fix to be had (track2xmcd)
  but in most instances it should be made to work correctly.
* DONE Perform type inference wherever possible
  Anything with a single output file (trackcat and record2track)
  should be able to infer its output type from the track suffix, if possible.
* DONE Add "comment" field support to all metadata types
  Don't forget to add unit tests for comment field.
** TODO Sort "comment" fields correctly across all metadata types
** TODO Add --comment support to tracktag
* DONE Fix ID3v2 image support to handle Unicode descriptions
  The current implementation falls down on UTF-16 input,
  but I should have a solution from the COMM frame handler.
* DONE Limit ID3v2.2/2.3 to UCS-2 encoding
  The current implementation treats UCS-2 the same as UTF-16.
  This needs to be fixed so that really high unicode characters
  (above U+FFFF) are replaced with something within spec.
* DONE Unify ID3v2 frame handling
  In the beginning, there were text frames and Everything Else.
  Text frames were unicode strings,
  and Everything Else was a binary string of whatever.
  Now that ID3 is cluttered with APIC frames and COMM frames that need
  special treatment, ID3v2 needs an overhaul to more resemble FlacMetaData.
** DONE Ensure unknown frames are displayed correctly
   Anything that's not text, images or comments should get some sort
   of proper display instead of a Python object string.
* DONE Add app testing to the unit test suite
  Though not everything is unit-testable
  (such as the CD handling programs or anything X11)
  a lot of the batch programs are to some degree:
- [X] coverdump
- [X] track2track
- [X] trackcat
- [X] trackcmp
- [X] tracklength
- [X] tracklint
- [X] trackrename
- [X] tracksplit
- [X] tracktag
* DONE Add verbosity levels to programs
  Every batch program should support a -V --verbose flag
  with options for "silence","normal" (the default) and "debug".
  Silence shuts off everything but error messages.
  Normal is standard output behavior.
  Debug for additional debugging output.
- [X] cd2track
- [X] cd2xmcd
- [X] coverdump
- [X] record2track
- [X] track2cd (this will need to forward verbosity to cdrecord)
- [X] track2track
- [X] track2xmcd
- [X] trackcmp
- [X] trackrename
- [X] tracksplit
- [X] tracktag
- [X] tracklint
* DONE Add compression percentage display to trackinfo
  Though not massively useful, it'd be neat to see just how
  compressed audio tracks are, as a percentage of their original size.
* DONE Add support for W??? frames to ID3v2
  The various W??? frames are really just URLs and don't need to
  be displayed as hex-encoded blobs.
* DONE Add CUE/TOC support to track2cd
  It should be possible to burn a selection of tracks, or a disc image,
  from a cuesheet with all its indexes/ISRC/catalog data intact
  by passing --cue to track2cd.
* DONE Unify CUE/TOC support
  Cuesheets and cdrdao TOC files are largely interchangeable.
  They both feature a listing of track offsets and, optionally,
  CD-TEXT data, ISRCs and so on.
  These formats should be unified such that any program will
  handle them both automatically.
- [X] tracksplit
- [X] trackcat
- [X] tracktag
** DONE Update docs to mention CUE/TOC interchangeability
- [X] tracksplit
- [X] trackcat
- [X] tracktag
** DONE Support cuesheet from FlacMetaData directly
   Since we're parsing CUE/TOC files anyway, this data can be used
   to build FLAC CUESHEET blocks directly instead of punting
   this task to metaflac.
** DONE Add unit tests for TOC/CUE files, as well as embedded FLAC cuesheets
* DONE Update copyright text for 2009
* DONE Preserve metadata when using trackcat
  Any fields shared by all tracks should be merged into metadata
  for the newly combined track.
* DONE Don't route data though WAVE files unless necessary
  Currently, track2track routes through WAVE if both ends happen to
  support foreign RIFF chunks, whether the files have such chunks or not.
  This behavior needs to be modified such that only source files
  which actually have foreign chunks, and a target format that supports them,
  results in a pass through RIFF WAVE.
* DONE Convert editxmcd to PyGTK
  Although the dialog(1)-based version works in terminals and is curses-based,
  it's extremely hokey, error-prone and doesn't support any cut & paste.
  This needs to be reimplemented in PyGTK (since coverview already uses it)
  and made into a stable app someone would want to use.
** DONE Update XMCD support
   The current handling of XMCD files treats them only as very primative
   AlbumMetaData implementations.  This must be updated into something
   round-trippable if editxmcd is to be modernized.
*** DONE Add XMCD unit tests
*** DONE Update XMCD API documentation
* DONE Require Python 2.5
  Since Python 2.4 is in bugfix-only mode and barely supported,
  it's best to move the minimum version to Python 2.5 or better
  (which has already been superceded by Python 2.6).
  This reduces the amount of Python versions to test on
  and allows the use of more modern Python features which
  makes the code less clunky.
** TODO Update documentation to mention Python 2.5 requirement.
* DONE Expand WavPack's APEv2 tag coverage
  WavPack's official specification defines APEv2 tags such as
  "Cuesheet" and "Cover Art" which the APEv2 standard does not.
  It would be helpful to make WavPack's APEv2 tags a superset of regular APEv2.
** DONE Add image support to WavePackAPEv2
** DONE Add cuesheet support to WavePackAPEv2
* DONE Build unified cuesheet interface
  Once both FLAC and WavPack support embedded cuesheets,
  there will need to be a unified interface to support them.
  I expect this will be a simple pair of get_cuesheet/set_cuesheet
  methods, probably attached to the AudioFiles themselves
  rather than to MetaData objects.
** DONE Alter FLAC-specific cuesheet documentation to be more general
** DONE Ensure cuesheets are transferred properly when transcoding
** DONE Update trackcat to use the interface
** DONE Update tracksplit to use the interface
** DONE Update track2cd to use the interface
** DONE Document cuesheet interface
** DONE Add unit tests for embedded cuesheets across all formats
** DONE Add cuesheet import option to tracktag
   This can also use the --cue flag,
   for consistency with other image-handling programs like tracksplit.
   If given with a single, album-length track, --cue will import a cuesheet.
   If given with multiple tracks or a single track that's too short,
   --cue will function like --xmcd and act as a metadata source.
** DONE Update track2xmcd to support getting an XMCD file from CD image
* DONE Convert to Muspack SV8
  Now that Musepack SV8 is finalized, it should be the new default.
  The old SV7 command-line tools aren't well supported and don't
  seem to work outside of x86 platforms.
  SV7 streams are, in theory, backwards compatible so switching
  shouldn't be a problem.
* DONE Update coverview to look more standard
  It's currently a haphazard assortment of widgets
  rather than anything like a proper GTK app.
  It should be tweaked to look better.
* DONE Improve transcoding robustness
  Just about all of the to_pcm() and from_pcm() methods expect
  that their subprocess calls will work as expected.
  Though rare in practice, these need to be checked in case
  the child processes fail for any reason.
** DONE Check for invalid input/output files/permissions errors
   If an output file can't be read/written to for some reason
   (invalid permissions, etc.) generate a proper error message
   instead of throwing ugly IOExceptions or confusing errors.
- [X] cd2track
- [X] cd2xmcd
- [X] coverdump
- [X] editxmcd
- [X] record2track
- [X] track2cd
- [X] track2track
- [X] track2xmcd
- [X] trackcat
- [X] trackcmp
- [X] trackinfo
- [X] tracklength
- [X] tracklint
- [X] trackplay
- [X] trackrename
- [X] tracksplit
- [X] tracktag
* DONE Make text output consistent
  Currently, command-line programs generate output using a
  selection of scattered print statements - often accompanied by
  if blocks when verbosity is indicated - and haphazardly
  filtered through unicode.
  This should be replaced by a unified message system similar
  to Python's built-in logging module which can abstract away
  these difficulties.
** DONE Convert tty output to gettext-based strings
   This will not only make output messages more consistent across the tools,
   but will also allow for foreign language translations in the future.
- [X] cd2track
- [X] cd2xmcd
- [X] coverdump
- [X] record2track
- [X] track2cd
- [X] track2track
- [X] track2xmcd
- [X] trackcat
- [X] trackcmp
- [X] trackinfo
- [X] tracklength
- [X] tracklint
- [X] trackplay
- [X] trackrename
- [X] tracksplit
- [X] tracktag
*** DONE Convert output from audiotools module to gettext-based strings
- [X] __aiff__.py
- [X] __ape__.py
- [X] __au__.py
- [X] cue.py
- [X] __flac__.py
- [X] __freedb__.py
- [X] __id3__.py
- [X] __id3v1__.py
- [X] __image__.py
- [X] __init__.py
- [X] __m4a__.py
- [X] __mp3__.py
- [X] __musepack__.py
- [X] __speex__.py
- [X] toc.py
- [X] __vorbiscomment__.py
- [X] __vorbis__.py
- [X] __wavpack__.py
- [X] __wav__.py
** DONE Add unit tests for tty output
   All programs which generate output should be unit tested
   so that all code paths are assured of printing the messages they're
   supposed to print, at the streams they're supposed to print on,
   and in the proper encoding settings.
- [X] coverdump
- [X] track2track
- [X] track2xmcd
- [X] trackcat
- [X] trackcmp
- [X] trackinfo
- [X] tracklength
- [X] tracklint
- [X] trackrename
- [X] tracksplit
- [X] tracktag
** DONE Convert --help output to gettext-based strings
** DONE Convert GUI programs to gettext-based strings
- [X] coverview
- [X] editxmcd
** DONE Convert "Usage" output to gettext-based strings
* DONE Update tracksplit's man page
  It now supports more of track2track's options
* DONE Support total tracks/total albums metadata fields
** DONE Add support for fields in the metadata tags
- [X] Add support in Vorbis Comments
- [X] Add support in ID3v2
- [X] Add support in M4A
- [X] Add support in APEv2
** DONE Add support in utilities
- [X] Add support in tracktag
- [X] Add support in cd2track
- [X] Add support in tracksplit
- [X] Add support in trackcat
** DONE Add unit tests
** DONE Add fields to --format output
** DONE Update man pages with fields information
* DONE Integrate better MetaData merging
  There's a few areas in which MetaData from multiple sources must
  be merged in an intelligent manner,
  such as where tracksplit takes a source track an XMCD file.
  Now that a preliminary MetaData.merge() classmethod is in place,
  this process must be integrated consistently.
- [X] track2track
- [X] trackrename
- [X] tracksplit
- [X] tracktag
** DONE Add unit tests for MetaData merging process
- [X] track2track
- [X] trackrename
- [X] tracksplit
- [X] tracktag
* DONE Improve M4A metadata handling
** DONE Make M4A metadata updating less destructive
  Like FLAC, not all fields need to be wiped out when overwriting
  old metadata with new.
** DONE Add more M4A-specific unit tests
* DONE Add more system information to audiotools-config
  All BIN-referenced binaries should be accounted for.
  Thumbnailing status and requirements should be shown.
* DONE Add cdinfo utility
  Analagous to trackinfo, but for an inserted CD.
  This would be a better location for cd2xmcd's "-i" option.
** DONE Add cdinfo man page
** DONE Link cdinfo man page to other utility man pages
* DONE Add manual page for audiotools.cfg
  It'll be easier to check what the options are from a man page
  rather than having to check the website or PDF doc.
* DONE Convert vorbiscomment dependency to Python
  This would remove the last app-based MetaData-setting utility
  and may pave the way for adding cover art to Ogg Vorbis
  (assuming I can find the standard for a secondary stream of image data)
* DONE Add metadata deletion capability
  It would be helpful to have the low-level capability of deleting
  either part of a MetaData tag or the entire tag altogether.
  For example, deleting the "track_name" field would delete
  a Vorbis comment's "TITLE" field.
  Or, deleting the MetaData from MP3 would remove all the ID3v2/ID3v1 tags.
** DONE Add delattr to ID3v1
* DONE Integrate pyconstruct as a submodule
* DONE Add undo capability to editxmcd
* DONE Add --cue option to track2xmcd
  One should be able to pull metadata from CD images
  without having to embed the cuesheet.
** DONE Add unit tests for track2xmcd's --cue option
** DONE Update man page
* DONE Group --help output more intelligently
  For tools with a large number of options (such as track2track or tracktag)
  the --help output is particularly jumbled.
  Use more of optparse's features to make this output clearer.
- [X] cd2track
- [X] cd2xmcd
- [X] track2track
- [X] track2xmcd
- [X] tracksplit
- [X] tracktag
* DONE Check for FLAC metadata chunk overflow
  Although APEv2 and ID3 tags support very large objects (hundreds of MB),
  FLAC metadata chunks have a maxmimum of about 16MB per chunk,
  which may be hit accidentally.
* DONE Fix or replace Python's built-in aifc module
  The current implementation suffers from bugs.
** DONE Document AIFF better
* DONE Add MusicBrainz support
  It would be helpful to have external metadata support beyond FreeDB,
  since FreeDB is very primitive.
** DONE Ensure that MusicBrainz is interchangeable with FreeDB/XMCD
*** DONE Unify track2xmcd/track2mb, cd2xmcd/cd2mb
    Based on preliminary testing, MusicBrainz's output is better than FreeDB's
    but its album coverage is not as broad.
    In addition, nobody wants to run their albums through two separate tools
    in order to extract metadata for tagging.  The best solution is
    for tools to try both and output the one that's most complete.
*** DONE Extend editxmcd to MusicBrainz XML
    Although editxmcd was originally designed specifically for XMCD files
    and MusicBrainz's XML format differs radically, no one should have to
    know whether an album metadata file is one or the other.
    Therefore, editxmcd should be extended with additional fields
    to handle XML backend data if necessary.
*** DONE Handle multiple Release entries with single Disc ID
*** DONE Allow MusicBrainz XML output for new editxmcd files
    FreeDB output should also be an option, however.
** DONE Add MusicBrainz protocol/format documentation
** DONE Add MusicBrainz-specific unit tests
- [X] track2track
- [X] track2xmcd
- [X] trackrename
- [X] tracksplit
- [X] tracktag
** DONE Update --help text to indicate MusicBrainz compatibility
- [X] cd2xmcd
- [X] editxmcd
- [X] track2track
- [X] track2xmcd
- [X] trackrename
- [X] tracksplit
- [X] tracktag
** DONE Update man pages to indiciate MusicBrainz compatibility
- [X] cd2xmcd
- [X] editxmcd
- [X] track2track
- [X] track2xmcd
- [X] trackrename
- [X] tracksplit
- [X] tracktag
** DONE Update documentation with MusicBrainz config file fields
** DONE Ensure missing XML fields are handled correctly
   The MusicBrainz XML spec allows most fields to be missing altogether
   (such as <title>).  editxmcd should add these fields in the proper place
   if necessary.
*** DONE Add unit tests for improperly reordered XML fields
* DONE Ensure .glade files are found
  Not all systems place Python data files in the same locations.
* DONE Convert to_pcm()/from_pcm() to FrameList-based I/O
  Passing specifically-sized blobs of binary data between conversion
  routines worked well when those routines are little more than
  subprocess black-boxes.  However, this approach works less well
  whenever actual sample values are required, or when processing is needed.
  In those cases, going from integers to strings, converting the strings
  back to integers for processing, then bouncing them into strings once
  again becomes needless work.
  A more sensible approach is to keep all data as FrameList-compatible
  objects (stored as C-based lists of int32s behind-the-scenes)
  and convert that data to/from strings only at the beginning and end
  of processing.
** DONE Build C-based audiotools.pcm.FrameList object
   This needs to closely match audiotools.FrameList's functionality
   and combine all the PCM conversion features from audiotools.pcmreader
*** DONE Integrate audiotools.pcm.FrameList with i_array structures
*** DONE Make audiotools.pcm.FrameList into a standalone object
    So standalone test codecs can use them, such as "flacenc"
*** DONE Unit test audiotools.pcm.FrameList
** DONE Convert FLAC encoder/decoder to use FrameList objects
   - [X] flacenc
   - [X] audiotools.decoders.FlacDecoder
   - [X] audiotools.encoders.encode_flac
** DONE Convert to_pcm()/from_pcm() routines to use FrameList objects
   - [X] AAC
   - [X] AIFF
   - [X] Sun AU
   - [X] FLAC
   - [X] M4A
   - [X] MP2
   - [X] MP3
   - [X] Ogg FLAC
   - [X] Ogg Speex
   - [X] WAVE
   - [X] WavPack
** DONE Convert CDTrackReader/OffsetCDTrackReader to use FrameList objects
** DONE Convert PCMConverter to use FrameList objects
** DONE Convert ReplayGainReader to use FrameList objects
** DONE Ensure integrated FrameList passes all unit tests
** DONE Remove deprecated audiotools.FrameList object
** DONE Remove deprecated pcmstream.PCMStreamReader object
** DONE Convert pcmstream module to resample module
** DONE Avoid importing audiotools.pcm so often
   Other C libraries often import audiotools.pcm via Python callbacks
   This library importing should be cached when possible.
   - [X] cdiomodule
   - [X] pcmreader
   - [X] replaygain
   - [X] resample
** DONE Check for memory leaks
** DONE Add FrameList and FloatFrameList programming documentation
** DONE Remove .copy() method
   Since FrameLists are now immutable, there's no need for it
** DONE Make pcm objects self-documenting
   For example, their methods and functions should give useful info
   when checked with "help()"
* DONE Add native ReplayGain handling routines
** DONE Add native ReplayGain handling to FlacAudio/OggFlacAudio
** DONE Ensure add_replay_gain()'s exceptions are caught
   Errors during calculation may raise ValueError,
   which must be caught anywhere the function is called
** DONE Add ReplayGain unit tests
** DONE Ensure ReplayGain works properly on 8bps and 24bps output
** DONE Ensure ReplayGain is applied consistently
   Although cd2track and tracksplit are guaranteed
   to generate only one album at a time, track2track and tracktag are not.
   If multiple albums are applied gain at once,
   add_replay_gain must be called on an album-by-album basis
   rather than on the entire set.
** DONE Double-check ReplayGainReader
   Ensure its output is consistent with other implementations.
* DONE Fix multi-channel audio handling
  It's important that channel mapping information be preserved
  when transcoding between sources with 3+ channels.
  This likely means another flag for PCMReader so that
  from_pcm() can build a file with the proper channel mask set.
  However, it may also be necessary to build some sort of
  channel reordering mechanism in the event that formats differ
  on how channels are to be ordered in the file.
** Channel Counts and Ordering
| Format     | Maximum Channels | Ordering               |
|------------+------------------+------------------------|
| AAC        |               48 | stereo-only (via faac) |
| AIFF       |             2^16 | predefined             |
| Sun AU     |             2^32 | mostly undefined       |
| FLAC       |                8 | as WAVE                |
| M4A        |               48 | as WAVE?               |
| MP2        |                2 | stereo-only            |
| MP3        |                2 | stereo-only            |
| Musepack   |                2 | stereo-only            |
| Ogg FLAC   |                8 | as WAVE                |
| Ogg Vorbis |              255 | predefined             |
| Ogg Speex  |             2^32 | stereo-only            |
| RIFF WAVE  |             2^16 | predefined             |
| WavPack    |               16 | as WAVE                |
|------------+------------------+------------------------|
** DONE Fix AudioFile definitions to support channel_mask()
   - [X] AACAudio
   - [X] AiffAudio
   - [X] AuAudio
   - [X] FlacAudio
   - [X] M4AAudio
   - [X] MP2Audio
   - [X] MP3Audio
   - [X] OggFlacAudio
   - [X] VorbisAudio
   - [X] SpeexAudio
   - [X] WaveAudio
   - [X] WavPackAudio
** DONE Fix to_pcm() methods to support channel_mask
   - [X] AACAudio
   - [X] AiffAudio
   - [X] AuAudio
   - [X] FlacAudio
   - [X] M4AAudio
   - [X] MP2Audio
   - [X] MP3Audio
   - [X] OggFlacAudio
   - [X] VorbisAudio
   - [X] SpeexAudio
   - [X] WaveAudio
   - [X] WavPackAudio
** DONE Fix from_pcm() classmethods to support channel_mask
   - [X] AACAudio
   - [X] AiffAudio
   - [X] AuAudio
   - [X] FlacAudio
   - [X] M4AAudio
   - [X] MP2Audio
   - [X] MP3Audio
   - [X] OggFlacAudio
   - [X] VorbisAudio
   - [X] SpeexAudio
   - [X] WaveAudio
   - [X] WavPackAudio
** DONE Fix alternate PCMReaders to support channel_mask
   - [X] BufferedPCMReader
   - [X] PCMConverter
   - [X] ReplayGainReader
   - [X] CDTrackReader
   - [X] OffsetCDTrackReader
   - [X] PCMCat
** DONE Handle undefined channel masks in a sane way
*** DONE Fix to_pcm() methods to output undefined ChannelMasks
    If a format has not defined channel assignments for a given
    channel count, its to_pcm() method should return undefined ChannelMasks.
    - [X] AACAudio
    - [X] AiffAudio
    - [X] AuAudio
    - [X] FlacAudio
    - [X] M4AAudio
    - [X] MP2Audio
    - [X] MP3Audio
    - [X] OggFlacAudio
    - [X] VorbisAudio
    - [X] SpeexAudio
    - [X] WaveAudio
    - [X] WavPackAudio
*** DONE Fix from_pcm() classmethods to accept undefined ChannelMasks
    So long as the number of channels is acceptable,
    audio formats are free to place undefined ChannelMasks
    in whatever arrangement they'd like.
    - [X] AACAudio
    - [X] AiffAudio
    - [X] AuAudio
    - [X] FlacAudio
    - [X] M4AAudio
    - [X] MP2Audio
    - [X] MP3Audio
    - [X] OggFlacAudio
    - [X] VorbisAudio
    - [X] SpeexAudio
    - [X] WaveAudio
    - [X] WavPackAudio
** DONE Unit test multichannel encoding and channel_mask handling
*** DONE Ensure all AudioFile types have a working channel_mask() method
    Even 2 channel audio should yield something valid.
*** DONE Ensure all to_pcm() methods yield a matching channel_mask attribute
*** DONE Ensure channel_mask is preserved between from_pcm(to_pcm()) calls
*** DONE Ensure channel_mask is preserved between to_wave()/from_wave() calls
*** DONE Ensure channels are actually stored in the proper order
    This is less of an issue for .wav, .flac, .oga or .wv
    which already store channels in RIFF WAVE order
    and more of an issue for Ogg Vorbis and other formats that do not.
*** DONE Ensure UnsupportedChannelMask is raised when necessary
    This includes calls to from_pcm() and from_wave()
** DONE Ensure PCMReader.channel_mask is always an integer
* DONE Fix the unit test error messages
* DONE Make the programming documentation web-capable
   It should render consistently with the regular Python reference docs
   and be placed both in the source tree and on the website
   for better accessability.
** DONE Document audiotools
    - [X] AudioFile
    - [X] BufferedPCMReader
    - [X] ChannelMask
    - [X] ExecQueue
    - [X] Image
    - [X] MetaData
    - [X] PCMConverter
    - [X] PCMReader
    - [X] PCMCat
    - [X] ReorderedPCMReader
    - [X] ReplayGain
    - [X] ReplayGainReader
    - [X] Messenger
    - [X] AlbumMetaData
    - [X] CDTrackLog
    - [X] CDDA
    - [X] CDTrackReader
    - [X] calculate_replay_gain
    - [X] filename_to_type
    - [X] find_glade_file
    - [X] group_tracks
    - [X] open
    - [X] open_directory
    - [X] open_files
    - [X] pcm_cmp
    - [X] pcm_split
    - [X] read_metadata_file
    - [X] read_sheet
    - [X] stripped_pcm_cmp
    - [X] transfer_data
    - [X] transfer_framelist_data
    - [X] BIN
    - [X] TYPE_MAP
    - [X] VERSION
    - [X] AVAILABLE_TYPES
** DONE Document audiotools.pcm
    - [X] FloatFrameList
    - [X] FrameList
    - [X] from_channels
    - [X] from_float_channels
    - [X] from_float_frames
    - [X] from_frames
    - [X] from_list
** DONE Document audiotools.resample
    - [X] Resampler
** DONE Document audiotools.replaygain
    - [X] ReplayGain
** DONE Document audiotools.cdio
    - [X] CDDA
    - [X] set_read_callback
** DONE Document audiotools.cue
    - [X] Cuesheet
    - [X] read_cuesheet
    - [X] CueException
** DONE Document audiotools.toc
    - [X] TOCFile
    - [X] read_tocfile
    - [X] TOCException
* DONE Make reference documentation render consistently
** DONE Ensure documents render in letter and A4 size
** DONE Add Creative Commons licensing to source code and doc itself
** DONE Add internal PDF linkage
   The file should have working bookmarks
   and internal links so one can click directly to a chapter
** DONE Add new introduction
** DONE Basics
*** DONE Hexadecimal
*** DONE Endianness
*** DONE Signed values
    How to decode/encode signed integers should be properly explained
*** DONE Character Encodings
*** DONE PCM
** DONE .wav
*** DONE the RIFF WAVE stream
*** DONE the fmt chunk
*** DONE the WAVEFORMATEXTENSIBLE fmt chunk
*** DONE the data chunk
*** DONE channel mapping
** DONE .aiff
*** DONE the AIFF stream
*** DONE the COMM chunk
**** TODO 80 bit IEEE standard 754 floating point
*** DONE the SSND chunk
** DONE .au
*** DONE the AU stream
*** DONE the AU header
** DONE .flac
*** DONE the FLAC file stream
*** DONE FLAC metadata
**** DONE the PADDING metadata block
**** DONE the APPLICATION metadata block
**** DONE the SEEKTABLE metadata block
**** DONE the VORBIS_COMMENT metadata block
**** DONE the PICTURE metadata block
**** DONE the CUESHEET metadata block
*** DONE FLAC decoding
**** DONE the CONSTANT subframe
**** DONE the VERBATIM subframe
**** DONE the FIXED subframe
**** DONE the LPC subframe
**** DONE the Residual
***** DONE Rice Encoding
**** DONE Channels
**** DONE Wasted bits per sample
*** DONE FLAC encoding
**** DONE Metadata header
**** DONE the STREAMINFO metadata block
**** DONE Frame header
**** DONE Channel assignment
**** DONE Subframe header
**** DONE the CONSTANT subframe
**** DONE the VERBATIM subframe
**** DONE the FIXED subframe
**** DONE the LPC subframe
***** DONE Windowing
***** DONE Computing autocorrelation
***** DONE LP coefficient calculation
***** DONE Best order estimation
***** DONE Best order exhaustive search
***** DONE Quantizing coefficients
***** DONE Calculation Residual
**** DONE the Residual
***** DONE Residual Values
*** DONE the Checksums
**** TODO CRC-8
**** TODO CRC-16
** DONE .ape
*** DONE the Monkey's Audio stream
*** DONE the APE Descriptor
*** DONE the APE Header
*** DONE the APEv2 tag
*** DONE the APEv2 tag header/footer
*** DONE the APEv2 flags
** DONE .wv
*** DONE the WavPack file stream
*** DONE a WavPack block header
*** DONE a WavPack sub-block header
** DONE .mp3
*** DONE the MP3 file stream
*** DONE an MPEG frame header
**** DONE the Xing header
*** DONE the ID3v1 tag
**** DONE ID3v1
**** DONE ID3v1.1
*** DONE the ID3v2 tag
**** DONE the ID3v2 stream
**** DONE ID3v2.2
***** DONE the ID3v2.2 Header
***** DONE an ID3v2.2 Frame
***** DONE ID3v2.2 Frame IDs
***** DONE the PIC Frame
**** DONE ID3v2.3
***** DONE the ID3v2.3 Header
***** DONE an ID3v2.3 Frame
***** DONE ID3v2.3 Frame IDs
***** DONE the APIC Frame
**** DONE ID3v2.4
***** DONE the ID3v2.4 Header
***** DONE an ID3v2.4 Frame
***** DONE ID3v2.4 Frame IDs
***** DONE the APIC Frame
** DONE .ogg
*** DONE the Ogg file stream
*** DONE an Ogg Page
*** DONE Ogg packets
*** DONE the Identification packet
*** DONE the Comment packet
*** DONE Channel assignment
** DONE .spx
*** DONE the Header packet
*** DONE the Comment packet
** DONE .oga
*** DONE the Ogg FLAC file stream
*** DONE the STREAMINFO metadata packet
*** DONE the Metadata packets
** DONE .m4a
*** DONE the QuickTime file stream
*** DONE a QuickTime atom
*** DONE Container atoms
*** DONE M4A atoms
**** DONE the ftyp atom
**** DONE the mvhd atom
**** DONE the tkhd atom
**** DONE the mdhd atom
**** DONE the hdlr atom
**** DONE the smhd atom
**** DONE the dref atom
**** DONE the stsd atom
**** DONE the mp4a atom
**** DONE the stts atom
**** DONE the stsc atom
**** DONE the stsz atom
**** DONE the stco atom
**** DONE the meta atom
***** DONE the trkn sub-atom
***** DONE the disk sub-atom
** DONE .mpc
*** DONE Musepack SV7
**** DONE the Musepack SV7 file stream
**** DONE the Musepack SV7 header
*** DONE Musepack SV8
**** DONE the Musepack SV8 file stream
**** DONE Nut-encoded values
**** DONE the SH packet
**** DONE the SE packet
**** DONE the RG packet
**** DONE the EI packet
** DONE FreeDB
*** DONE Native Protocol
**** DONE the Disc ID
**** DONE Initial Greeting
**** DONE Client-Server Handshake
**** DONE Set Protocol Level
**** DONE Query Database
**** DONE Read XMCD Data
**** DONE Close Connection
*** DONE Web Protocol
*** DONE XMCD
** DONE MusicBrainz
*** DONE Searching Releases
**** DONE The Disc ID
**** DONE Server Query
**** DONE Release XML
*** DONE MusieBrainz XML
** DONE ReplayGain
*** DONE Applying ReplayGain
*** DONE Calculating ReplayGain
**** DONE the Equal Loudness Filter
     This should be re-documented to be closer to the actual implementation
***** TODO the Yule Filter
***** TODO the Buffer Filter
***** TODO a Filtering Example
**** DONE RMS Energy Blocks
**** DONE Statistical Processing and Calibration
** DONE References
** DONE Remove old troff reference documentation
** DONE Add title and author to PDF documentation
* DONE Ensure make(1) from doc/ directory builds both doc trees
* DONE Seperate unreadable files from unknown files
  Files we're unable to read should be handled differently
  from files we're unable to understand.
** DONE Update audiotools.open() to raise IOErrors
** DONE Update audiotools.open_files() to handle IOErrors
** DONE Update audiotools.open_directory() to handle IOErrors
** DONE Update internal calls to open()/open_files() to handle IOErrors
   - [X] __flac__.py
   - [X] __m4a__.py
   - [X] __mp3__.py
   - [X] __vorbis__.py
   - [X] __wavpack__.py
   - [X] __wav__.py
** DONE Update tools which use open()/open_files() to handle IOErrors
   - [X] coverdump
   - [X] editxmcd
   - [X] track2cd
   - [X] track2track
   - [X] track2xmcd
   - [X] trackcat
   - [X] trackcmp
   - [X] trackinfo
   - [X] tracklength
   - [X] tracklint
   - [X] trackplay
   - [X] trackrename
   - [X] tracksplit
   - [X] tracktag
** DONE Add unit tests to demonstrate new behavior
** DONE Update programming documentation with new behavior
* DONE Ensure embedded cuesheets aren't clobbered by adding more metadata
* DONE Adjust %(album_track_number)s to accomodate more than 9 albums
  For example, track 2 of 7, album 5 of 11 in format
  "%(album_track_number)s - %(track_name)s.%(suffix)s should be:
  "0502 - name.suffix"
* DONE editxmcd's "New" command should work with embedded cuesheets
  Selecting a single disc image with embedded cuesheets should
  fill in the proper XMCD/MusicBrainz fields
* DONE Ensure add_replay_gain used on hi-def tracks doesn't raise errors
* DONE Add Shorten support
  I don't expect people have a lot of shn files lying around
  and nobody should be using it for new data
  (though I'll add a rudimentary encoder for completeness' sake)
  but it's interesting to document for historical reasons.
** DONE Build complete decoder
   - [X] DIFF0
   - [X] DIFF1
   - [X] DIFF2
   - [X] DIFF3
   - [X] QUIT
   - [X] BLOCKSIZE
   - [X] BITSHIFT
   - [X] QLPC
   - [X] ZERO
   - [X] VERBATIM
   I'll likely limit support to Shorten version2/3
   since generating older versions will be a challenge
   and this format is obscure enough as it is.
** DONE Build partial encoder
   - [X] DIFF0
   - [X] DIFF1
   - [X] DIFF2
   - [X] QUIT
   - [X] BLOCKSIZE
   - [X] ZERO
   - [X] VERBATIM
*** DONE Convert partial encoder for standalone use
    To ensure there aren't any memory leaks
** DONE Add ShortenAudio type to audiotools Python core
** DONE Add Shorten-specific unit tests
** DONE Document Shorten
   - [X] Shorten data types
   - [X] the Shorten file stream
   - [X] the decoding process
   - [X] the encoding process
* DONE trackcmp should give exact PCM frame/byte of first mismatch
** DONE update unit tests to cover new behavior
   - [X] test_trackcmp
   - [X] test_trackcmp1
   - [X] test_trackcmp2
   - [X] test_trackcmp3
   - [X] test_trackcmp4
** DONE update manual page to cover new behavior
* DONE Add analyzers for built-in decoders
  Analagous to flac(1)'s --analyze option,
  this will be an .analyze_frame() method that returns a Python dict
  of ints/lists/dicts containing frame data on each pass,
  or None at the stream's end.
  This will provide both an easier way to visualize the file's internals,
  and also a debugging aid.
** DONE FlacDecoder
** DONE SHNDecoder
** DONE ALACDecoder
* DONE Add more examples
  A lot of handy new features aren't documented with examples and walkthroughs.
  Examples to add include:
- [X] a full multi-CD example, detailing the use of --album-number
- [X] an image embedding walkthrough
- [X] a CD image creation, splitting, burning example involving TOC/CUE files
- [X] an XMCD walkthrough with fetching, editing and tagging
* DONE Update documentation to cover concrete MetaData classes
  - [X] ApeTag
  - [X] FlacMetaData
  - [X] ID3v1Comment
  - [X] ID3v22Comment
  - [X] ID3v23Comment
  - [X] ID3v24Comment
  - [X] ID3CommentPair
  - [X] M4AMetaData
  - [X] VorbisComment
* DONE Ensure man pages install correctly on Mac OS X
* DONE add a %(basename)s --format attribute
  For example, given the path: "/foo/bar/01 - track name.mp3"
  the %(basename)s attribute would be: "01 - track name"
  allowing one to ignore its internal metadata entirely
  and use original names.
** DONE Update AudioFile.track_name to support attribute
** DONE Update tools that call AudioFile.track_name
   - [X] cd2track
   - [X] track2track
   - [X] trackrename
   - [X] tracksplit
** DONE Update man pages for tools that call AudioFile.track_name
   - [X] track2track.1
   - [X] trackrename.1
   - [X] audiotools.cfg.5
** DONE Add unit test support for new attribute
** DONE Add documentation for new field to programming reference
** DONE Add documentation for format strings to programming reference
* DONE Update AudioFile.track_name classmethod
  the previous behavior was a kludge cobbled together over time
  Its new call method is:  track_name(file_path, metadata, format)
  so that track_number and album_number can be pulled from file_path
  directly instead of passed in from outside.
** DONE Update tools to support new calling method
   - [X] track2track
   - [X] cd2track
   - [X] trackrename
   - [X] tracksplit
** DONE Update programming documentation
** DONE Add unit tests
** DONE Update old unit tests with new behavior
** DONE unit test suffix field
* DONE Update Python code to support PEP 8
  Following accepted Python style should make the code more
  accessible and maintainable in the long run.
  It's also a good opportunity to clean up and simplify code
  without changing the actual API interface.
** DONE Update core modules
*** DONE __aiff__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] IEEE_Extended
     - [X] AiffException
     - [X] AiffAudio
     - [X] AiffAudio.bits_per_sample
     - [X] AiffAudio.channels
     - [X] AiffAudio.channel_mask
     - [X] AiffAudio.lossless
     - [X] AiffAudio.total_frames
     - [X] AiffAudio.sample_rate
     - [X] AiffAudio.is_type
     - [X] AiffAudio.chunks
     - [X] AiffAudio.comm_chunk
     - [X] AiffAudio.chunk_files
     - [X] AiffAudio.get_metadata
     - [X] AiffAudio.set_metadata
     - [X] AiffAudio.delete_metadata
     - [X] AiffAudio.to_pcm
     - [X] AiffAudio.from_pcm
     - [X] AIFFChannelMask
     - [X] AIFFChannelMask.channels
*** DONE __ape__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] ApeTagItem
     - [X] ApeTagItem.build
     - [X] ApeTagItem.binary
     - [X] ApeTagItem.external
     - [X] ApeTagItem.string
     - [X] ApeTag
     - [X] ApeTag.converted
     - [X] ApeTag.merge
     - [X] ApeTag.supports_images
     - [X] ApeTag.add_image
     - [X] ApeTag.delete_image
     - [X] ApeTag.images
     - [X] ApeTag.read
     - [X] ApeTag.build
     - [X] ApeTaggedAudio
     - [X] ApeTaggedAudio.get_metadata
     - [X] ApeTaggedAudio.set_metadata
     - [X] ApeTaggedAudio.delete_metadata
     - [X] ApeAudio
     - [X] ApeAudio.is_type
     - [X] ApeAudio.lossless
     - [X] ApeAudio.supports_foreign_riff_chunks
     - [X] ApeAudio.has_foreign_riff_chunks
     - [X] ApeAudio.bits_per_sample
     - [X] ApeAudio.channels
     - [X] ApeAudio.total_frames
     - [X] ApeAudio.sample_rate
     - [X] ApeAudio.to_wave
     - [X] ApeAudio.from_wave
*** DONE __au__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] AuAudio
     - [X] AuAudio.is_type
     - [X] AuAudio.lossless
     - [X] AuAudio.bits_per_sample
     - [X] AuAudio.channels
     - [X] AuAudio.channel_mask
     - [X] AuAudio.sample_rate
     - [X] AuAudio.total_frames
     - [X] AuAudio.to_pcm
     - [X] AuAudio.from_pcm
     - [X] AuAudio.track_name
*** DONE __flac__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [ ] FlacException
     - [X] FlacMetaDataBlockTooLarge
     - [X] FlacMetaDataBlock
     - [X] FlacMetaDataBlock.build_block
     - [X] FlacMetaData
     - [X] FlacMetaData.converted
     - [X] FlacMetaData.merge
     - [X] FlacMetaData.add_image
     - [X] FlacMetaData.delete_image
     - [X] FlacMetaData.images
     - [X] FlacMetaData.metadata_blocks
     - [X] FlacMetaData.build
     - [X] FlacMetaData.supports_images
     - [X] FlacVorbisComment
     - [X] FlacVorbisComment.build_block
     - [X] FlacVorbisComment.converted
     - [X] FlacPictureComment
     - [X] FlacPictureComment.converted
     - [X] FlacPictureComment.type_string
     - [X] FlacPictureComment.build
     - [X] FlacPictureComment.build_block
     - [X] FlacCueSheet
     - [X] FlacCueSheet.build_block
     - [X] FlacCueSheet.converted
     - [X] FlacCueSheet.catalog
     - [X] FlacCueSheet.ISRCs
     - [X] FlacCueSheet.indexes
     - [X] FlacCueSheet.pcm_lengths
     - [X] FlacAudio
     - [X] FlacAudio.is_type
     - [X] FlacAudio.channel_mask
     - [X] FlacAudio.lossless
     - [X] FlacAudio.supports_foreign_riff_chunks
     - [X] FlacAudio.get_metadata
     - [X] FlacAudio.set_metadata
     - [X] FlacAudio.metadata_length
     - [X] FlacAudio.delete_metadata
     - [X] FlacAudio.set_cuesheet
     - [X] FlacAudio.get_cuesheet
     - [X] FlacAudio.to_pcm
     - [X] FlacAudio.from_pcm
     - [X] FlacAudio.has_foreign_riff_chunks
     - [X] FlacAudio.riff_wave_chunks
     - [X] FlacAudio.to_wave
     - [X] FlacAudio.from_wave
     - [X] FlacAudio.bits_per_sample
     - [X] FlacAudio.channels
     - [X] FlacAudio.total_frames
     - [X] FlacAudio.sample_rate
     - [X] FlacAudio.add_replay_gain
     - [X] FlacAudio.can_add_replay_gain
     - [X] FlacAudio.lossless_replay_gain
     - [X] FlacAudio.replay_gain
     - [X] FlacAudio.sub_pcm_tracks
     - [X] OggFlacAudio
     - [X] OggFlacAudio.is_type
     - [X] OggFlacAudio.get_metadata
     - [X] OggFlacAudio.set_metadata
     - [X] OggFlacAudio.metadata_length
     - [X] OggFlacAudio.to_pcm
     - [X] OggFlacAudio.from_pcm
     - [X] OggFlacAudio.sub_pcm_tracks
     - [X] OggFlacAudio.supports_foreign_riff_chunks
*** DONE __freedb__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] XMCDException
     - [X] XMCD
     - [X] XMCD.key_digits
     - [X] XMCD.build
     - [X] XMCD.read
     - [X] XMCD.read_data
     - [X] XMCD.from_files
     - [X] XMCD.from_cuesheet
     - [X] XMCD.metadata
     - [X] DiscID
     - [X] DiscID.from_cdda
     - [X] DiscID.add
     - [X] DiscID.offsets
     - [X] DiscID.length
     - [X] DiscID.idsuffix
     - [X] DiscID.freedb_id
     - [X] DiscID.toxmcd
     - [X] FreeDBException
     - [X] FreeDB
     - [X] FreeDB.connect
     - [X] FreeDB.close
     - [X] FreeDB.write
     - [X] FreeDB.read
     - [X] FreeDB.query
     - [X] FreeDB.read_data
     - [X] FreeDBWeb
     - [X] FreeDBWeb.connect
     - [X] FreeDBWeb.close
     - [X] FreeDBWeb.write
     - [X] FreeDBWeb.read
     - [X] FreeDBWeb.query
     - [X] FreeDBWeb.read_data
     - [X] get_xmcd
*** DONE __id3__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] UCS2Codec
     - [X] UCS2Codec.fix_char
     - [X] UCS2Codec.encode
     - [X] UCS2Codec.decode
     - [X] UnsupportedID3v2Version
     - [X] Syncsafe32
     - [X] UBInt24
     - [X] WidecharCStringAdapter
     - [X] UCS2CString
     - [X] UTF16CString
     - [X] UTF16BECString
     - [X] ID3v22Frame
     - [X] ID3v22Frame.build
     - [X] ID3v22Frame.parse
     - [X] ID3v22TextFrame
     - [X] ID3v22TextFrame.total
     - [X] ID3v22TextFrame.from_unicode
     - [X] ID3v22TextFrame.build
     - [X] ID3v22ComFrame
     - [X] ID3v22ComFrame.from_unicode
     - [X] ID3v22ComFrame.build
     - [X] ID3v22PicFrame
     - [X] ID3v22PicFrame.type_string
     - [X] ID3v22PicFrame.build
     - [X] ID3v22PicFrame.converted
     - [X] ID3v22Comment
     - [X] ID3v22Comment.add_image
     - [X] ID3v22Comment.delete_image
     - [X] ID3v22Comment.images
     - [X] ID3v22Comment.parse
     - [X] ID3v22Comment.converted
     - [X] ID3v22Comment.merge
     - [X] ID3v22Comment.build
     - [X] ID3v22Comment.skip
     - [X] ID3v22Comment.read_id3v2_comment
     - [X] ID3v23Frame
     - [X] ID3v23Frame.build
     - [X] ID3v23Frame.parse
     - [X] ID3v23TextFrame
     - [X] ID3v23TextFrame.total
     - [X] ID3v23TextFrame.from_unicode
     - [X] ID3v23TextFrame.build
     - [X] ID3v23PicFrame
     - [X] ID3v23PicFrame.build
     - [X] ID3v23PicFrame.converted
     - [X] ID3v23ComFrame
     - [X] ID3v23ComFrame.from_unicode
     - [X] ID3v23ComFrame.build
     - [X] ID3v23Comment
     - [X] ID3v23Comment.add_image
     - [X] ID3v23Comment.delete_image
     - [X] ID3v23Comment.images
     - [X] ID3v23Comment.build
     - [X] ID3v24Frame
     - [X] ID3v24Frame.build
     - [X] ID3v24Frame.parse
     - [X] ID3v24TextFrame
     - [X] ID3v24TextFrame.total
     - [X] ID3v24TextFrame.from_unicode
     - [X] ID3v24TextFrame.build
     - [X] ID3v24PicFrame
     - [X] ID3v24PicFrame.build
     - [X] ID3v24PicFrame.converted
     - [X] ID3v24ComFrame
     - [X] ID3v24ComFrame.from_unicode
     - [X] ID3v24ComFrame.build
     - [X] ID3v24Comment
     - [X] ID3v24Comment.build
     - [X] ID3CommentPair
     - [X] ID3CommentPair.converted
     - [X] ID3CommentPair.merge
     - [X] ID3CommentPair.images
     - [X] ID3CommentPair.add_image
     - [X] ID3CommentPair.delete_image
     - [X] ID3CommentPair.supports_images
*** DONE __id3v1__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] ID3v1Comment
     - [X] ID3v1Comment.read_id3v1_comment
     - [X] ID3v1Comment.build_id3v1
     - [X] ID3v1Comment.supports_images
     - [X] ID3v1Comment.converted
     - [X] ID3v1Comment.build_tag
     - [X] ID3v1Comment.images
*** DONE __image__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] image_metrics
     - [X] ImageMetrics
     - [X] InvalidImage
     - [X] InvalidJPEG
     - [X] InvalidPNG
     - [X] InvalidBMP
     - [X] InvalidGIF
     - [X] InvalidTIFF
     - [X] can_thumbnail
     - [X] thumbnail_formats
     - [X] thumbnail_image
*** DONE __init__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] __init__.py
     - [X] RawConfigParser
     - [X] RawConfigParser.get_default
     - [X] RawConfigParser.getint_default
     - [X] find_glade_file
     - [X] OptionParser
     - [X] Messenger
     - [X] str_width
     - [X] VerboseMessenger
     - [X] VerboseMessenger.output
     - [X] VerboseMessenger.partial_output
     - [X] VerboseMessenger.new_row
     - [X] VerboseMessenger.blank_row
     - [X] VerboseMessenger.divider_row
     - [X] VerboseMessenger.output_column
     - [X] VerboseMessenger.output_rows
     - [X] VerboseMessenger.info
     - [X] VerboseMessenger.partial_info
     - [X] VerboseMessenger.error
     - [X] VerboseMessenger.warning
     - [X] VerboseMessenger.usage
     - [X] VerboseMessenger.filename
     - [X] VerboseMessenger.ansi
     - [X] VerboseMessenger.ansi_err
     - [X] SilentMessenger
     - [X] SilentMessenger.output
     - [X] SilentMessenger.partial_output
     - [X] SilentMessenger.warning
     - [X] SilentMessenger.info
     - [X] SilentMessenger.partial_info
     - [X] UnsupportedFile
     - [X] InvalidFile
     - [X] InvalidFormat
     - [X] EncodingError
     - [X] UnsupportedChannelMask
     - [X] UnsupportedChannelCount
     - [X] DecodingError
     - [X] open
     - [X] open_files
     - [X] open_directory
     - [X] UnknownAudioType
     - [X] AmbiguousAudioType
     - [X] filename_to_type
     - [X] ChannelMask
     - [X] ChannelMask.defined
     - [X] ChannelMask.undefined
     - [X] ChannelMask.channels
     - [X] ChannelMask.index
     - [X] ChannelMask.from_fields
     - [X] ChannelMask.from_channels
     - [X] PCMReader
     - [X] PCMReader.read
     - [X] PCMReader.close
     - [X] PCMReaderError
     - [X] PCMReaderError.read
     - [X] PCMReaderError.close
     - [X] ReorderedPCMReader
     - [X] ReorderedPCMReader.read
     - [X] ReorderedPCMReader.close
     - [X] transfer_data
     - [X] transfer_framelist_data
     - [X] threaded_transfer_framelist_data
     - [X] pcm_cmp
     - [X] stripped_pcm_cmp
     - [X] pcm_frame_cmp
     - [X] PCMCat
     - [X] PCMCat.read
     - [X] PCMCat.close
     - [X] BufferedPCMReader
     - [X] BufferedPCMReader.close
     - [X] BufferedPCMReader.read
     - [X] pcm_split
     - [X] PCMConverter
     - [X] PCMConverter.read
     - [X] PCMConverter.close
     - [X] applicable_replay_gain
     - [X] calculate_replay_gain
     - [X] InterruptableReader
     - [X] InterruptableReader.stop
     - [X] InterruptableReader.send_data
     - [X] InterruptableReader.read
     - [X] ignore_sigint
     - [X] make_dirs
     - [X] MetaData
     - [X] MetaData.converted
     - [X] MetaData.supports_images
     - [X] MetaData.images
     - [X] MetaData.front_covers
     - [X] MetaData.back_covers
     - [X] MetaData.leaflet_pages
     - [X] MetaData.media_images
     - [X] MetaData.other_images
     - [X] MetaData.add_image
     - [X] MetaData.delete_image
     - [X] MetaData.merge
     - [X] AlbumMetaData
     - [X] AlbumMetaData.metadata
     - [X] MetaDataFileException
     - [X] Image
     - [X] Image.suffix
     - [X] Image.type_string
     - [X] Image.new
     - [X] Image.thumbnail
     - [X] ReplayGain
     - [X] UnsupportedTracknameField
     - [X] AudioFile
     - [X] AudioFile.is_type
     - [X] AudioFile.bits_per_sample
     - [X] AudioFile.channels
     - [X] AudioFile.channel_mask
     - [X] AudioFile.lossless
     - [X] AudioFile.set_metadata
     - [X] AudioFile.get_metadata
     - [X] AudioFile.delete_metadata
     - [X] AudioFile.total_frames
     - [X] AudioFile.cd_frames
     - [X] AudioFile.sample_rate
     - [X] AudioFile.to_pcm
     - [X] AudioFile.from_pcm
     - [X] AudioFile.to_wave
     - [X] AudioFile.from_wave
     - [X] AudioFile.supports_foreign_riff_chunks
     - [X] AudioFile.has_foreign_riff_chunks
     - [X] AudioFile.track_number
     - [X] AudioFile.album_number
     - [X] AudioFile.track_name
     - [X] AudioFile.add_replay_gain
     - [X] AudioFile.can_add_replay_gain
     - [X] AudioFile.lossless_replay_gain
     - [X] AudioFile.replay_gain
     - [X] AudioFile.set_cuesheet
     - [X] AudioFile.get_cuesheet
     - [X] AudioFile.has_binaries
     - [X] DummyAudioFile
     - [X] DummyAudioFile.get_metadata
     - [X] DummyAudioFile.cd_frames
     - [X] DummyAudioFile.track_number
     - [X] DummyAudioFile.sample_rate
     - [X] DummyAudioFile.total_frames
     - [X] SheetException
     - [X] read_sheet
     - [X] parse_timestamp
     - [X] build_timestamp
     - [X] sheet_to_unicode
     - [X] at_a_time
     - [X] CDDA
     - [X] RawCDDA
     - [X] RawCDDA.length
     - [X] RawCDDA.close
     - [X] RawCDDA.first_sector
     - [X] RawCDDA.last_sector
     - [X] OffsetCDDA
     - [X] OffsetCDDA.close
     - [X] CDTrackLog
     - [X] CDTrackReader
     - [X] CDTrackReader.offset
     - [X] CDTrackReader.length
     - [X] CDTrackReader.log
     - [X] CDTrackReader.read
     - [X] CDTrackReader.close
     - [X] OffsetCDTrackReader
     - [X] OffsetCDTrackReader.offset
     - [X] OffsetCDTrackReader.length
     - [X] OffsetCDTrackReader.log
     - [X] OffsetCDTrackReader.read
     - [X] OffsetCDTrackReader.close
     - [X] read_metadata_file
     - [X] ExecQueue
     - [X] ExecQueue.execute
     - [X] ExecQueue.run
     - [X] BitstreamReader
     - [X] BitstreamReader.byte_align
     - [X] BitstreamReader.read
     - [X] BitstreamReader.unread
     - [X] BitstreamReader.read_signed
     - [X] BitstreamReader.unary
     - [X] BitstreamReader.tell
     - [X] BitstreamReader.close
     - [X] BitstreamWriter
     - [X] BitstreamWriter.byte_align
     - [X] BitstreamWriter.write
     - [X] BitstreamWriter.write_signed
     - [X] BitstreamWriter.unary
     - [X] BitstreamWriter.tell
     - [X] BitstreamWriter.close
*** DONE __m4a_atoms__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] VersionLength
     - [X] AtomAdapter
     - [X] Atom
     - [X] AtomListAdapter
     - [X] AtomContainer
     - [X] AtomWrapper
*** DONE __m4a__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] M4AAudio_faac
     - [X] M4AAudio_faac.channel_mask
     - [X] M4AAudio_faac.is_type
     - [X] M4AAudio_faac.lossless
     - [X] M4AAudio_faac.channels
     - [X] M4AAudio_faac.bits_per_sample
     - [X] M4AAudio_faac.sample_rate
     - [X] M4AAudio_faac.cd_frames
     - [X] M4AAudio_faac.total_frames
     - [X] M4AAudio_faac.get_metadata
     - [X] M4AAudio_faac.set_metadata
     - [X] M4AAudio_faac.delete_metadata
     - [X] M4AAudio_faac.to_pcm
     - [X] M4AAudio_faac.from_pcm
     - [X] M4AAudio_faac.can_add_replay_gain
     - [X] M4AAudio_faac.lossless_replay_gain
     - [X] M4AAudio_faac.add_replay_gain
     - [X] M4AAudio_nero
     - [X] M4AAudio_nero.to_pcm
     - [X] M4AAudio_nero.from_pcm
     - [X] M4AAudio_nero.to_wave
     - [X] M4AAudio_nero.from_wave
     - [X] ILST_Atom
     - [X] M4AMetaData
     - [X] M4AMetaData.binary_atom
     - [X] M4AMetaData.text_atom
     - [X] M4AMetaData.trkn_atom
     - [X] M4AMetaData.disk_atom
     - [X] M4AMetaData.covr_atom
     - [X] M4AMetaData.images
     - [X] M4AMetaData.add_image
     - [X] M4AMetaData.delete_image
     - [X] M4AMetaData.converted
     - [X] M4AMetaData.merge
     - [X] M4AMetaData.to_atom
     - [X] M4AMetaData.supports_images
     - [X] M4ACovr
     - [X] M4ACovr.converted
     - [X] ALACAudio
     - [X] ALACAudio.is_type
     - [X] ALACAudio.total_frames
     - [X] ALACAudio.channel_mask
     - [X] ALACAudio.cd_frames
     - [X] ALACAudio.lossless
     - [X] ALACAudio.to_pcm
     - [X] ALACAudio.from_pcm
     - [X] ALACAudio.to_wave
     - [X] ALACAudio.from_wave
     - [X] ADTSException
     - [X] AACAudio
     - [X] AACAudio.is_type
     - [X] AACAudio.bits_per_sample
     - [X] AACAudio.channels
     - [X] AACAudio.lossless
     - [X] AACAudio.total_frames
     - [X] AACAudio.sample_rate
     - [X] AACAudio.to_pcm
     - [X] AACAudio.from_pcm
     - [X] AACAudio.aac_frames
     - [X] AACAudio.aac_frame_count
*** DONE __mp3__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] MP3Exception
     - [X] MP3Audio
     - [X] MP3Audio.is_type
     - [X] MP3Audio.lossless
     - [X] MP3Audio.to_pcm
     - [X] MP3Audio.from_pcm
     - [X] MP3Audio.bits_per_sample
     - [X] MP3Audio.channels
     - [X] MP3Audio.sample_rate
     - [X] MP3Audio.get_metadata
     - [X] MP3Audio.set_metadata
     - [X] MP3Audio.delete_metadata
     - [X] MP3Audio.cd_frames
     - [X] MP3Audio.total_frames
     - [X] MP3Audio.can_add_replay_gain
     - [X] MP3Audio.lossless_replay_gain
     - [X] MP3Audio.add_replay_gain
     - [X] MP2Audio
     - [X] MP2Audio.is_type
     - [X] MP2Audio.from_pcm
*** DONE __musepack__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] NutValue
     - [X] Musepack8StreamReader
     - [X] Musepack8StreamReader.packets
     - [X] MusepackAudio
     - [X] MusepackAudio.from_pcm
     - [X] MusepackAudio.is_type
     - [X] MusepackAudio.sample_rate
     - [X] MusepackAudio.total_frames
     - [X] MusepackAudio.channels
     - [X] MusepackAudio.bits_per_sample
     - [X] MusepackAudio.lossless
*** DONE __musicbrainz__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] get_xml_nodes
     - [X] get_xml_text_node
     - [X] reorder_xml_children
     - [X] MBDiscID
     - [X] MBDiscID.from_cdda
     - [X] MBDiscID.offsets
     - [X] MusicBrainz
     - [X] MusicBrainz.connect
     - [X] MusicBrainz.close
     - [X] MusicBrainz.read_data
     - [X] MBXMLException
     - [X] MusicBrainzReleaseXML
     - [X] MusicBrainzReleaseXML.read
     - [X] MusicBrainzReleaseXML.read_data
     - [X] MusicBrainzReleaseXML.metadata
     - [X] MusicBrainzReleaseXML.from_files
     - [X] MusicBrainzReleaseXML.from_cuesheet
     - [X] MusicBrainzReleaseXML.build
     - [X] get_mbxml
*** DONE __shn__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] ShortenAudio
     - [X] ShortenAudio.is_type
     - [X] ShortenAudio.bits_per_sample
     - [X] ShortenAudio.channels
     - [X] ShortenAudio.channel_mask
     - [X] ShortenAudio.lossless
     - [X] ShortenAudio.total_frames
     - [X] ShortenAudio.sample_rate
     - [X] ShortenAudio.to_pcm
     - [X] ShortenAudio.from_pcm
     - [X] ShortenAudio.to_wave
     - [X] ShortenAudio.from_wave
     - [X] ShortenAudio.supports_foreign_riff_chunks
     - [X] ShortenAudio.has_foreign_riff_chunks
*** DONE __speex__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] UnframedVorbisComment
     - [X] SpeexAudio
     - [X] SpeexAudio.is_type
     - [X] SpeexAudio.to_pcm
     - [X] SpeexAudio.from_pcm
     - [X] SpeexAudio.set_metadata
     - [X] SpeexAudio.can_add_replay_gain
*** DONE __vorbiscomment__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] VorbisComment
     - [X] VorbisComment.supports_images
     - [X] VorbisComment.images
     - [X] VorbisComment.converted
     - [X] VorbisComment.merge
     - [X] VorbisComment.build
*** DONE __vorbis__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] OggStreamReader
     - [X] OggStreamReader.close
     - [X] OggStreamReader.packets
     - [X] OggStreamReader.pages
     - [X] OggStreamReader.pages_to_packets
     - [X] OggStreamReader.calculate_ogg_checksum
     - [X] OggStreamWriter
     - [X] OggStreamWriter.close
     - [X] OggStreamWriter.write_page
     - [X] OggStreamWriter.build_pages
     - [X] VorbisAudio
     - [X] VorbisAudio.is_type
     - [X] VorbisAudio.lossless
     - [X] VorbisAudio.bits_per_sample
     - [X] VorbisAudio.channels
     - [X] VorbisAudio.channel_mask
     - [X] VorbisAudio.total_frames
     - [X] VorbisAudio.sample_rate
     - [X] VorbisAudio.to_pcm
     - [X] VorbisAudio.from_pcm
     - [X] VorbisAudio.set_metadata
     - [X] VorbisAudio.get_metadata
     - [X] VorbisAudio.delete_metadata
     - [X] VorbisAudio.add_replay_gain
     - [X] VorbisAudio.can_add_replay_gain
     - [X] VorbisAudio.lossless_replay_gain
     - [X] VorbisAudio.replay_gain
     - [X] VorbisChannelMask
     - [X] VorbisChannelMask.channels
*** DONE __wavpack__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] SymlinkPCMReader
     - [X] SymlinkPCMReader.read
     - [X] SymlinkPCMReader.close
     - [X] SymlinkPCMReader.new
     - [X] WavePackAPEv2
     - [X] WavePackAPEv2.converted
     - [X] WavPackAudio
     - [X] WavPackAudio.is_type
     - [X] WavPackAudio.lossless
     - [X] WavPackAudio.supports_foreign_riff_chunks
     - [X] WavPackAudio.channel_mask
     - [X] WavPackAudio.get_metadata
     - [X] WavPackAudio.has_foreign_riff_chunks
     - [X] WavPackAudio.frames
     - [X] WavPackAudio.sub_frames
     - [X] WavPackAudio.bits_per_sample
     - [X] WavPackAudio.channels
     - [X] WavPackAudio.total_frames
     - [X] WavPackAudio.sample_rate
     - [X] WavPackAudio.from_pcm
     - [X] WavPackAudio.to_wave
     - [X] WavPackAudio.to_pcm
     - [X] WavPackAudio.from_wave
     - [X] WavPackAudio.add_replay_gain
     - [X] WavPackAudio.can_add_replay_gain
     - [X] WavPackAudio.replay_gain
     - [X] WavPackAudio.get_cuesheet
     - [X] WavPackAudio.set_cuesheet
*** DONE __wav__.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] WaveReader
     - [X] WaveReader.read
     - [X] WaveReader.close
     - [X] TempWaveReader
     - [X] TempWaveReader.close
     - [X] WavException
     - [X] WaveAudio
     - [X] WaveAudio.is_type
     - [X] WaveAudio.lossless
     - [X] WaveAudio.supports_foreign_riff_chunks
     - [X] WaveAudio.has_foreign_riff_chunks
     - [X] WaveAudio.channel_mask
     - [X] WaveAudio.to_pcm
     - [X] WaveAudio.from_pcm
     - [X] WaveAudio.to_wave
     - [X] WaveAudio.from_wave
     - [X] WaveAudio.total_frames
     - [X] WaveAudio.sample_rate
     - [X] WaveAudio.channels
     - [X] WaveAudio.bits_per_sample
     - [X] WaveAudio.can_add_replay_gain
     - [X] WaveAudio.lossless_replay_gain
     - [X] WaveAudio.add_replay_gain
     - [X] WaveAudio.track_name
     - [X] WaveAudio.fmt_chunk_to_channel_mask
     - [X] WaveAudio.chunk_ids
     - [X] WaveAudio.chunks
     - [X] WaveAudio.wave_from_chunks
     - [X] WaveAudio.pcm_split
*** DONE cue.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] cue.py
     - [X] CueException
     - [X] tokens
     - [X] get_value
     - [X] parse
     - [X] Cuesheet
     - [X] Cuesheet.catalog
     - [X] Cuesheet.single_file_type
     - [X] Cuesheet.indexes
     - [X] Cuesheet.pcm_lengths
     - [X] Cuesheet.ISRCs
     - [X] Cuesheet.file
     - [X] Track
     - [X] Track.ISRC
     - [X] read_cuesheet
*** DONE toc.py
**** DONE adjust syntax
**** DONE add docstrings
     - [X] toc.py
     - [X] TOCException
     - [X] parse
     - [X] TOCFile
     - [X] TOCFile.catalog
     - [X] TOCFile.indexes
     - [X] TOCFile.pcm_lengths
     - [X] TOCFile.ISRCs
     - [X] TOCFile.file
     - [X] Track
     - [X] Track.ISRC
     - [X] read_tocfile
** DONE Update utilities
   - [X] audiotools-config
   - [X] cd2track
   - [X] cd2xmcd
   - [X] cdinfo
   - [X] coverdump
   - [X] coverview
   - [X] editxmcd
   - [X] record2track
   - [X] track2cd
   - [X] track2track
   - [X] track2xmcd
   - [X] trackcat
   - [X] trackcmp
   - [X] trackinfo
   - [X] tracklength
   - [X] tracklint
   - [X] trackplay
   - [X] trackrename
   - [X] tracksplit
   - [X] tracktag
** DONE Update tests
   - [X] test.py
   - [X] test_streams.py
* DONE Update C code to support PEP 7
  - [X] array.c
  - [X] array.h
  - [X] bitstream_r.c
  - [X] bitstream_r.h
  - [X] bitstream_w.c
  - [X] bitstream_w.h
  - [X] cdiomodule.c
  - [X] decoders.c
  - [X] decoders.h
  - [X] encoders.c
  - [X] encoders.h
  - [X] md5.c
  - [X] md5.h
  - [X] pcm.c
  - [X] pcm.h
  - [X] pcmreader.c
  - [X] pcmreader.h
  - [X] replaygain.c
  - [X] replaygain.h
  - [X] resample.c
  - [X] resample.h
  - [X] decoders/alaac.c
  - [X] decoders/alac.h
  - [X] decoders/flac.c
  - [X] decoders/flac_crc.c
  - [X] decoders/flac_crc.h
  - [X] decoders/flac.h
  - [X] decoders/shn.c
  - [X] decoders/shn.h
  - [X] encoders/alac.c
  - [X] encoders/alac.h
  - [X] encoders/alac_lpc.c
  - [X] encoders/alac_lpc.h
  - [X] encoders/flac.c
  - [X] encoders/flac.h
  - [X] encoders/flac_lpc.c
  - [X] encoders/flac_lpc.h
  - [X] encoders/shn.c
  - [X] encoders/shn.h
* DONE Add ALAC support
** DONE Build ALAC decoder
*** DONE Add audiotools.decoders.AlacDecoder object
*** DONE Add frame header parsing
*** DONE Add subframe header parsing
*** DONE Add wasted-bits block parsing
*** DONE Add residual decoding
*** DONE Ensure frame footer is checked
*** DONE Decode subframes
*** DONE Perform channel decorrelation
    - [X] leftweight zero
    - [X] leftweight nonzero
*** DONE Handle wasted-bits samples
*** DONE Return pcm.FrameList objects on calls to read()
*** DONE Ensure PCMReader-compatible fields are present
    - [X] sample_rate
    - [X] channels
    - [X] channel_mask
    - [X] bits_per_sample
*** DONE Ensure 16/24 bps streams work correctly
    - [X] 16bps
    - [X] 24bps
*** DONE Ensure 1/2 channel streams work correctly
    - [X] 1 channel
    - [X] 2 channels
*** DONE Ensure different sample rates work correctly
    - [X] 44100Hz
    - [X] 48000Hz
    - [X] 96000Hz
    - [X] 192000Hz
    (need to figure out what other sample rates ALAC supports)
*** DONE Update source to more closely match documentation
*** DONE Optimize for speed
** DONE Build ALAC encoder
*** DONE Add audiotools.encoders.encode_alac function
*** DONE Ensure verbatim ALAC file is written correctly
*** DONE Determine ALAC stream tunables
**** wasted bits for 24bps streams
**** interlacing shift
**** interlacing leftweight
**** prediction quantitization
**** coefficients
*** DONE extract wasted bits for 24bps streams
*** DONE correlate stereo samples
*** DONE determine coefficients/quantitization
*** DONE calculate residual values
*** DONE write residuals based on initial history/history multiplier/etc.
*** DONE handle random noise with uncompressed frames
*** DONE handle atypical sample rates properly
*** DONE Update source to more closely match documentation
*** DONE make interlacing shift and interlacing leftweight range options
*** DONE optimize for speed
** DONE Add ALACAudio type to audiotools Python core
** DONE Enable TestAlacAudio core tests
** DONE Add ALAC-specific unit tests
*** DONE test_streams
*** DONE test_small_files
*** DONE test_full_scale_deflection
*** DONE test_sines
    eliminate DeprecationWarning at construct/core.py:541
    which seems to be caused by 96000Hz input
*** DONE test_wasted_bps
*** DONE test_blocksizes
*** DONE test_frame_header_variations
*** DONE test_noise
*** DONE test_fractional
** DONE Document ALAC
*** DONE the ALAC file stream
*** DONE ALAC decoding
**** DONE Frame header
**** DONE Subframe header
**** DONE Residual decoding
**** DONE Residual decoding example
**** DONE Subframe decoding
     Simplify this to make it easier to understand
**** DONE Subframe decoding example
**** DONE Channel decorrelation
**** DONE Channel decorrelation example
**** DONE Wasted bits
**** DONE Wasted bits example
*** DONE ALAC encoding
**** DONE Figure out compliant atom contents
     - [X] ftyp
     - [X] moov->mvhd
     - [X] moov->trak->tkhd
     - [X] moov->trak->mdia->mdhd
     - [X] moov->trak->mdia->hdlr
     - [X] moov->trak->mdia->minf->smhd
     - [X] moov->trak->mdia->dinf->dref
     - [X] moov->trak->mdia->stbl->stsd->alac
     - [X] moov->trak->mdia->stbl->stts
     - [X] moov->trak->mdia->stbl->stsc
     - [X] moov->trak->mdia->stbl->stsz
     - [X] moov->trak->mdia->stbl->stco
     - [X] moov->udta->meta
     - [X] free
**** DONE Add forward references in "alac" atom description
**** DONE figure out if "meta" has required "----" sub-atoms
**** DONE extracting wasted bits for 24bps streams
**** DONE correlating stereo samples
**** DONE determining coefficients/quantitization
***** DONE Windowing
***** DONE Computing autocorrelation
***** DONE LP coefficient calculation
***** DONE Best order estimation
***** DONE Quantizing coefficients
**** DONE calculating residual values
     Simplify this to make it easier to understand
**** DONE writing residuals based on initial history/history multiplier/etc.
**** DONE Fix bitstream figs to be monospace font for binary digits
*** DONE verify A4 layout is correct
** DONE Update M4A metadata routines to exploit "free" atoms
   As with FLAC, rewriting the entire file should be avoided
** DONE Fix InvalidImage exceptions when reading test ALACs
** DONE Ensure UnsupportedChannels exception is handled by user-level tools
** DONE Ensure new ALACs work in iTunes
** DONE Ensure new ALACs work on iPods
** DONE Have M4A files group properly on iTunes/iPods
* DONE Remove xdelta requirement
  It's doesn't compile well on some platforms and is only used by tracklint
** DONE Build trivial binary delta routine
   Since most metadata formats make use of padding,
   we can use a simple XOR over their contents to generate
   a bidirectional patch that's optimized for tracklint's behavior.
   Since the bulk of such a patch should be NULLs,
   we can compress it with zlib/bz2 and achieve
   excellent compression.
* DONE Tweak documentation
** DONE Update indexes to account for warm-up samples
   The i index on the left and right hand sides must match.
   - [X] FLAC FIXED decoding
   - [X] FLAC LPC decoding
   - [X] FLAC FIXED encoding
   - [X] FLAC LPC encoding
** DONE Rewrite the FLAC channel assignment section
   Reference the side channel extra bit and add examples.
** DONE Add FLAC channel assignment encoding documentation
   Show its channel calculations and include an example.
* DONE Add C-based FLAC decoder
** DONE Add a variety of unit tests
** DONE Handle Rice escape codes
   Not sure how to test these, but they should be handled properly.
** DONE Ensure decoder raises the proper exceptions
* DONE indicate ReplayGain capabilities/binaries
  audiotools-config(1) should show what ReplayGain binaries are present
  and all audio classes that support it
* DONE update trackcmp to share trackverify's output interface
* DONE Add unary jump tables with a max value
  Since both Apple Lossless *and* WavPack have unary reading
  with a maximum upper limit of read bits, it makes sense
  to build a proper jump table for it.
  The size of our state limits the maximum to 8 bits,
  so larger maximums will be supported at a read_limited_unary() level.

  The trouble is, we need to differentiate between normal exits
  (we've hit the stop bit) and exits that hit the maximum value.
  So, the jump table itself must have a different syntax
  (probably an extra bit for "maximum value reached")
  and read_limited_unary() will likely return -1 in that event.
* DONE Add little-endian bitstream readers
** DONE integrate read functions into Bitstream struct
** DONE add bitstream.py jump tables for little-endian reading
   - [X] read_bits_table_le.h
   - [X] read_unary_table_le.h
   - [X] read_limited_unary_table_le.h
   - [X] unread_bit_table_le.h
** DONE add little-endian Bitstream functions
   - [X] bs_read_bits_le
   - [X] bs_read_bits64_le
   - [X] bs_unread_bit_le
   - [X] bs_read_unary_le
   - [X] bs_read_limited_unary_le
** DONE have bs_open() attach the proper endian functions
** DONE update Python BitstreamReader for little-endian operation
   This should function similar to the C one,
   with alignment specified at init-time.
   Or, perhaps replace Python reader with C-based one altogether.
** DONE add some basic Bitstream reader unit testing
** DONE allow endianness swapping
* DONE Add little-endian bitstream writers
** DONE add bitstream.py jump tables for little-endian writing
   - [X] write_bits_table_le.h
   - [X] write_unary_table_le.h
** DONE Add little-endian Bitstream functions
   - [X] write_bits_actual_le
   - [X] write_signed_bits_actual_le
   - [X] write_bits64_actual_le
   - [X] write_unary_actual_le
   - [X] byte_align_w_actual_le
** DONE have bs_open() attach the proper endian functions
** DONE update Python BitstreamWriter for little-endian operation
   Convert to a C type, similar to BitstreamReader
** DONE add some basic Bitstream writer unit testing
** DONE allow endianness swapping
* DONE integrate new endianness routines into existing routines
** DONE Convert Ogg verifier to proper little-endian operation
** DONE Swap endianness for proper FLAC VORBISCOMMENT writing
** DONE have bs_set_endianness create instruction in recorder-mode
   So that if we're recording an endianness shift,
   it gets set properly when "played back" to an actual writer.
   In fact, it may be a good idea to attach the set_endianness()
   function to the bitstream writer itself.
* DONE Build proper AlbumMetaDataFile class
  This is a superclass of FreeDB's XMCD and MusicBrainz's XML
  which wraps metadata containers into a consistent interface
  for use by editxmcd and command-line utilities.
** DONE Convert XMCD to AlbumMetaDataFile subclass
** DONE Add unit tests for XMCD
** DONE Convert MusicBrainzReleaseXML to AlbumMetaDataFile subclass
** DONE Add unit tests for MusicBrainzReleaseXML
** DONE Update utilities to use new interface
   - [X] tracksplit
   - [X] track2track
   - [X] track2xmcd
   - [X] trackrename
   - [X] tracktag
   - [ ] editxmcd
   - [X] cd2track
   - [X] cd2xmcd
** DONE Update old unit tests to new interface
** DONE Fix get_track to return blank artist name if not present
   Don't pull from the class artist name;
   have track_metadata() figure that out as appropriate instead.
*** DONE Fix unit tests for proper behavior
** DONE Document AlbumMetaDataFile
* DONE Update ALAC to handle multichannel audio
  What David Hammerton's reverse-engineered decoder described as
  a 3-bit frame footer isn't; it's actually a "stop" delimiter
  analagous to WavPack's block header stop bit.
  If it's not 0x7, keep reading frames and combine them
  channel-wise into a single multichannel chunk of output.

  iTunes and iPods still won't be able to handle such files,
  but XLD should be able to.
** DONE Update ALACDecoder's analyze_frame() method for multichannel
** DONE Update ALACDecoder's read() method for multichannel
** DONE Update encode_alac function for multichannel
** DONE Unit test multichannel ALAC encoding and decoding
** DONE Update decoding documentation describing multichannel handling
** DONE Update encoding documentation describing multichannel handling
* DONE Add higher sampling rate support to ReplayGain module
  Extract the higher rates from wvgain.c
  - [X] 8000Hz
  - [X] 11025Hz
  - [X] 12000Hz
  - [X] 16000Hz
  - [X] 18900Hz
  - [X] 22050Hz
  - [X] 24000Hz
  - [X] 32000Hz
  - [X] 37800Hz
  - [X] 44100Hz
  - [X] 48000Hz
  - [X] 56000Hz
  - [X] 64000Hz
  - [X] 88200Hz
  - [X] 96000Hz
  - [X] 112000Hz
  - [X] 128000Hz
  - [X] 144000Hz
  - [X] 176400Hz
  - [X] 192000Hz
** DONE Unit test sample rates
* DONE Allow audio type defaults to be selectable
** DONE Update tools to pull -t from config file
   - [X] cd2track
   - [X] record2track
   - [X] track2track
   - [X] trackcat
   - [X] tracksplit
** DONE Update tools to pull -q from config file
   - [X] cd2track
   - [X] record2track
   - [X] track2track
   - [X] trackcat
   - [X] tracksplit
** DONE Update audio formats to pull default quality from config file (if any)
   for all calls to from_pcm() and from_wave()
   - [X] aac
   - [X] flac
   - [X] m4a (Nero)
   - [X] m4a (faac)
   - [X] mp2
   - [X] mp3
   - [X] oga
   - [X] ogg
   - [X] spx
   - [X] wv
** DONE Update audiotools-config to display default type
** DONE Update audiotools-config to display default qualities
** DONE Update audiotools-config to select default type
** DONE Update audiotools-config to select default quality for a type
** DONE Document new configuration options in man pages
   - [X] audiotools-config
   - [X] cd2track
   - [X] record2track
   - [X] track2track
   - [X] trackcat
   - [X] tracksplit
   - [X] audiotools.cfg
* DONE Allow default verbosity to be selectable
** DONE Update audiotools-config to display default verbosity
** DONE Update audiotools-config to select default verbosity
** DONE Update tools to use default verbosity
   - [X] cd2track
   - [X] cd2xmcd
   - [X] coverdump
   - [X] record2track
   - [X] track2cd
   - [X] track2track
   - [X] track2xmcd
   - [X] trackcmp
   - [X] tracklint
   - [X] trackrename
   - [X] tracksplit
   - [X] tracktag
   - [X] trackverify
** DONE Document new configuration option in man pages
   - [X] audiotools-config
   - [X] audiotools.cfg
* DONE Shift common decoder/encoder routines to a common/ directory
  - [X] flac_crc.h
  - [X] flac_crc.c
  - [X] misc.h
  - [X] misc.c
  - [X] md5.h
  - [X] md5.c
* DONE Get coverview and editxmcd working on Mac OS X
** DONE editxmcd
*** DONE Update man page
** DONE Update coverview for dual PyGTK/Tkinter operation
   It's a simple enough app that it should be able to conditionally do both,
   especially since audiotools does most of the heavy lifting.
   This allows it to look like a proper app under X11
   and work at all everywhere else.

   It should look and function approximately the same on both.
*** DONE Remove glade requirement
    I'm sick of glade, and coverview should be small enough
    that it's not a problem to lay it out internally.
*** DONE Update coverview for PyGTK
*** DONE Update coverview for Tkinter
**** DONE Fixup error messages, if possible
*** DONE Add --gtk/--tkinter switches for conditional launch
    For testing purposes
*** DONE Cleanup conditional classes/helper functions
*** DONE Check for init-time errors
    Both in loading audiofiles and in import problems
    such as Mac OS's 32-bit problem
*** DONE Update man page
* DONE More graceful handling of broken files
  A lot of the track handlers assume that once the start of the file is good,
  the rest of it is following the spec.  This is not always the case.
** DONE All audio formats need to implement the error specification
   This means that:
   classmethod.is_type() must never error
   __init__() must raise InvalidFile if the filename's contents are invalid
   to_pcm() must return PCMReaderError if the decoder can't be built
   classmethod.from_pcm() must raise EncodingError if it can't encode file
   to_wave() must raise EncodingError if a wave can't be written
   classmethod.from_wave() must raise EncodingError if it can't encode file
   a failed to_wave() mustn't leave half-encoded .wav files behind
   a failed from_wave() mustn't leave half-encoded .wav files behind
   a failed from_pcm() mustn't leave a partially encoded file behind
   PCMReaders may raise IOError and ValueError on read()
   PCMReaders may raise DecodingError on close()
*** DONE AACAudio
    - [X] is_type() doesn't error
    - [X] __init__() raises InvalidFile
    - [X] to_pcm() returns PCMReaderError on decoder error
    - [X] from_pcm() raises EncodingError on encoder error
    - [X] from_wave() raises EncodingError on encoder error
    - [X] failed from_wave() deletes partial file
    - [X] failed from_pcm() deletes partial file
    - [X] PCMReader raises IOError/ValueError on read() if necessary
    - [X] PCMReader raises DecodingError on close() if necessary
*** DONE AiffAudio
    - [X] is_type() doesn't error
    - [X] __init__() raises InvalidFile
    - [X] to_pcm() returns PCMReaderError on decoder error
    - [X] from_pcm() raises EncodingError on encoder error
    - [X] to_wave() raises EncodingError on decoder error
    - [X] from_wave() raises EncodingError on encoder error
    - [X] failed to_wave() deletes partial file
    - [X] failed from_wave() deletes partial file
    - [X] failed from_pcm() deletes partial file
    - [X] PCMReader raises IOError/ValueError on read() if necessary
    - [X] PCMReader raises DecodingError on close() if necessary
*** DONE ALACAudio
    - [X] is_type() doesn't error
    - [X] __init__() raises InvalidFile
    - [X] to_pcm() returns PCMReaderError on decoder error
    - [X] from_pcm() raises EncodingError on encoder error
    - [X] to_wave() raises EncodingError on decoder error
    - [X] from_wave() raises EncodingError on encoder error
    - [X] failed to_wave() deletes partial file
    - [X] failed from_wave() deletes partial file
    - [X] failed from_pcm() deletes partial file
    - [X] PCMReader raises IOError/ValueError on read() if necessary
    - [X] PCMReader raises DecodingError on close() if necessary
*** DONE AuAudio
    - [X] is_type() doesn't error
    - [X] __init__() raises InvalidFile
    - [X] to_pcm() returns PCMReaderError on decoder error
    - [X] from_pcm() raises EncodingError on encoder error
    - [X] to_wave() raises EncodingError on decoder error
    - [X] from_wave() raises EncodingError on encoder error
    - [X] failed to_wave() deletes partial file
    - [X] failed from_wave() deletes partial file
    - [X] failed from_pcm() deletes partial file
    - [X] PCMReader raises IOError/ValueError on read() if necessary
    - [X] PCMReader raises DecodingError on close() if necessary
*** DONE FlacAudio
    - [X] is_type() doesn't error
    - [X] __init__() raises InvalidFile
    - [X] to_pcm() returns PCMReaderError on decoder error
    - [X] from_pcm() raises EncodingError on encoder error
    - [X] to_wave() raises EncodingError on decoder error
    - [X] from_wave() raises EncodingError on encoder error
    - [X] failed to_wave() deletes partial file
    - [X] failed from_wave() deletes partial file
    - [X] failed from_pcm() deletes partial file
    - [X] PCMReader raises IOError/ValueError on read() if necessary
    - [X] PCMReader raises DecodingError on close() if necessary
*** DONE M4AAudio_faac
    - [X] is_type() doesn't error
    - [X] __init__() raises InvalidFile
    - [X] from_pcm() raises EncodingError on encoder error
    - [X] from_wave() raises EncodingError on encoder error
    - [X] failed from_wave() deletes partial file
    - [X] failed from_pcm() deletes partial file
*** DONE M4AAudio_nero
    - [X] is_type() doesn't error
    - [X] __init__() raises InvalidFile
    - [X] to_pcm() returns PCMReaderError on decoder error
    - [X] from_pcm() raises EncodingError on encoder error
    - [X] to_wave() raises EncodingError on decoder error
    - [X] from_wave() raises EncodingError on encoder error
    - [X] failed to_wave() deletes partial file
    - [X] failed from_wave() deletes partial file
    - [X] failed from_pcm() deletes partial file
    - [X] PCMReader raises IOError/ValueError on read() if necessary
    - [X] PCMReader raises DecodingError on close() if necessary
*** DONE MP2Audio
    - [X] is_type() doesn't error
    - [X] __init__() raises InvalidFile
    - [X] to_pcm() returns PCMReaderError on decoder error
    - [X] from_pcm() raises EncodingError on encoder error
    - [X] to_wave() raises EncodingError on decoder error
    - [X] from_wave() raises EncodingError on encoder error
    - [X] failed to_wave() deletes partial file
    - [X] failed from_wave() deletes partial file
    - [X] failed from_pcm() deletes partial file
    - [X] PCMReader raises IOError/ValueError on read() if necessary
    - [X] PCMReader raises DecodingError on close() if necessary
*** DONE MP3Audio
    - [X] is_type() doesn't error
    - [X] __init__() raises InvalidFile
    - [X] to_pcm() returns PCMReaderError on decoder error
    - [X] from_pcm() raises EncodingError on encoder error
    - [X] to_wave() raises EncodingError on decoder error
    - [X] from_wave() raises EncodingError on encoder error
    - [X] failed to_wave() deletes partial file
    - [X] failed from_wave() deletes partial file
    - [X] failed from_pcm() deletes partial file
    - [X] PCMReader raises IOError/ValueError on read() if necessary
    - [X] PCMReader raises DecodingError on close() if necessary
*** DONE OggFlacAudio
    - [X] is_type() doesn't error
    - [X] __init__() raises InvalidFile
    - [X] to_pcm() returns PCMReaderError on decoder error
    - [X] from_pcm() raises EncodingError on encoder error
    - [X] to_wave() raises EncodingError on decoder error
    - [X] from_wave() raises EncodingError on encoder error
    - [X] failed to_wave() deletes partial file
    - [X] failed from_wave() deletes partial file
    - [X] failed from_pcm() deletes partial file
    - [X] PCMReader raises IOError/ValueError on read() if necessary
    - [X] PCMReader raises DecodingError on close() if necessary
*** DONE ShortenAudio
    - [X] is_type() doesn't error
    - [X] __init__() raises InvalidFile
    - [X] to_pcm() returns PCMReaderError on decoder error
    - [X] from_pcm() raises EncodingError on encoder error
    - [X] to_wave() raises EncodingError on decoder error
    - [X] from_wave() raises EncodingError on encoder error
    - [X] failed to_wave() deletes partial file
    - [X] failed from_wave() deletes partial file
    - [X] failed from_pcm() deletes partial file
    - [X] PCMReader raises IOError/ValueError on read() if necessary
    - [X] PCMReader raises DecodingError on close() if necessary
*** DONE SpeexAudio
    - [X] is_type() doesn't error
    - [X] __init__() raises InvalidFile
    - [X] from_pcm() raises EncodingError on encoder error
    - [X] failed from_wave() deletes partial file
    - [X] failed from_pcm() deletes partial file
*** DONE VorbisAudio
    - [X] is_type() doesn't error
    - [X] __init__() raises InvalidFile
    - [X] to_pcm() returns PCMReaderError on decoder error
    - [X] from_pcm() raises EncodingError on encoder error
    - [X] to_wave() raises EncodingError on decoder error
    - [X] from_wave() raises EncodingError on encoder error
    - [X] failed to_wave() deletes partial file
    - [X] failed from_wave() deletes partial file
    - [X] failed from_pcm() deletes partial file
    - [X] PCMReader raises IOError/ValueError on read() if necessary
    - [X] PCMReader raises DecodingError on close() if necessary
*** DONE WaveAudio
    - [X] is_type() doesn't error
    - [X] __init__() raises InvalidFile
    - [X] to_pcm() returns PCMReaderError on decoder error
    - [X] from_pcm() raises EncodingError on encoder error
    - [X] to_wave() raises EncodingError on decoder error
    - [X] from_wave() raises EncodingError on encoder error
    - [X] failed to_wave() deletes partial file
    - [X] failed from_wave() deletes partial file
    - [X] failed from_pcm() deletes partial file
    - [X] PCMReader raises IOError/ValueError on read() if necessary
    - [X] PCMReader raises DecodingError on close() if necessary
*** DONE WavPackAudio
    - [X] is_type() doesn't error
    - [X] __init__() raises InvalidFile
    - [X] to_pcm() returns PCMReaderError on decoder error
    - [X] from_pcm() raises EncodingError on encoder error
    - [X] to_wave() raises EncodingError on decoder error
    - [X] from_wave() raises EncodingError on encoder error
    - [X] failed to_wave() deletes partial file
    - [X] failed from_wave() deletes partial file
    - [X] failed from_pcm() deletes partial file
    - [X] PCMReader raises IOError/ValueError on read() if necessary
    - [X] PCMReader raises DecodingError on close() if necessary
** DONE Check for invalid files at the tool level
   If an invalid file is encountered, display a proper
   user-readable error message explaining what's wrong
   with the file.
*** DONE track2cd
*** DONE track2track
*** DONE trackcat
*** DONE trackcmp
*** DONE trackplay
*** DONE tracksplit
** DONE Document ValueError/IOError behavior
   Both in docstrings and in the rst documentation.
* TODO Ensure non-image cuesheets are handled properly
  There are 4 different types of cuesheets,
  1 single file type and 3 different multiple file variants.
  We should be able to translate between them if necessary, and if possible.
* TODO Add Python3 support
** TODO Update C modules to compile on Python3
   - [ ] audiotools.cdio
   - [ ] audiotools.resample
   - [ ] audiotools.pcm
   - [ ] audiotools.replaygain
   - [ ] audiotools.decoders
   - [ ] audiotools.encoders
** TODO Update Python modules to operate on Python3
   - [ ] audiotools __init__ core
   - [ ] __aiff__
   - [ ] __ape__ ?
   - [ ] __au__
   - [ ] __flac__
   - [ ] __freedb__
   - [ ] __id3__
   - [ ] __id3v1__
   - [ ] __image__
   - [ ] __m4a__
   - [ ] __m4a_atoms__
   - [ ] __mp3__
   - [ ] __musepack__ ?
   - [ ] __musicbrainz__
   - [ ] __shn__
   - [ ] __speex__
   - [ ] __vorbis__
   - [ ] __vorbiscomment__
   - [ ] __wav__
   - [ ] cue
   - [ ] toc
** TODO Patch Construct for Python3
   Since pyconstruct hasn't been updated in almost 2 years,
   I'll likely have to update it myself to ensure it'll run on Python3.
** TODO Remove Python Imaging Library support?
   Unless this gets ported, I'll need an alternative method to make thumbnails
** TODO Remove PyGTK support?
   Unless this gets ported, I'll need another way to make GUIs.
   Perhaps I'll look into Tkinter again, which is portable
   but may not have the widgets I want.
* TODO Add support for genre tag?
  I'm not a big fan of the genre tag.
  Unlike track number, album name, ISRC, etc. in which a value
  can be reliably determined from the source material (e.g. back of the CD),
  genre is akin to a "rating" tag. Its value varies from person to person
  and this makes it less valuable for archival purposes.

  In addition, the genre tag itself is implemented in incompatible ways.
  APEv2 uses a chunk of text, ID3v1 uses an integer representing one
  of many designated genre labels, ID3v2 uses a mix of genre byte
  and/or text string, and so on.

  That said, the genre field shows up in a lot of players.
  So, some grudging support for it would probably be appreciated.
* TODO Add support for System->cdrom_offset
  This will automatically apply offset samples when reading CDs
  so that rips will have the appropate amount of null samples.
** DONE Add offset support when ripping
   Automatically apply the configfile's cdrom_offset value to tracks
   during reading.
** TODO Add offset support when burning?
   cd2track and track2cd should round-trip properly
   If cd2track applies a sample offset when reading, does track2cd
   need to apply that same offset when writing?
   One would presume a drive's read offset and write offset are the same,
   but that may not be correct.
* TODO Convert TOC and CUE handling to proper grammars
  Although the current ad-hoc method works in most cases,
  it would be better to use a more formal method to parse these files
  which can be proven to handle all legal files.
  I expect this will require PLY or some similar lexx/yacc mechanism
  which I'll bundle to avoid adding any extra depencies.
* TODO Add C-based FLAC encoder
** DONE Use VERBATIM subframes when necessary
** DONE Add significant initial padding blocks
   This will save a lot of time during retagging after FLAC creation
** DONE Add a variety of unit tests
   - [X] test_stream.sh
   - [X] test_flac.sh
** DONE Convert i_array size and data types to typedefs
** DONE Convert f_array size and data types to typedefs
** DONE Add more comprehensive encoding documentation
** DONE Add a variety of assert() statements
   As with unit tests, these ensure everything is working during testing
   without a performance penalty at runtime.
** DONE Handle foreign RIFF chunks
** DONE Ensure FLACs work on a variety of other decoders
   Although decoding properly on the reference decoder *should* guarantee
   the file works everywhere, the only way to be certain is to test it.
** DONE Ensure encoder raises the proper exceptions
** DONE Support Rice2 partitions?
   The reference encoder uses these for more efficient handling of 24-bit audio
   but I'm not sure they're strictly necessary for my more basic encoder.
** DONE Support wasted-bits-per-sample?
   I don't think I've ever seen these used on actual audio data
   that isn't artificial and hasn't been processed specifically for its use.
   As with Rice2, it's something that may get added later.
** DONE Handle multi-channel PCM data correctly
   Anything higher than 2 channels needs to set a channel mask
   and the vorbis comment to the proper value.
   I expect this will be a long-term project
   coinciding with re-engineering the to_pcm()/from_pcm() methods.
** DONE Remove external MD5 dependency
** TODO Generate SEEKTABLE blocks
* TODO Replace magic numbers with named constants
  There's still a few instances of magic numbers in use,
  in the __flac__.py module, for instance.
* TODO Support disc metadata submission
  If a disc is not found on FreeDB or MusicBrainz,
  there should be some mechanism to submit user-defined data
  to those services.
* TODO get trackplay working on Mac OS X
  There must be some way to pipe PCM data to its audio system
  without the need for additional libraries.
* TODO build track2cover/xmcd2cover utilities
  It would be helpful to have tools that could query
  online cover databases and retrieve images for tagging purposes.
  track2cover can replace coverdump, functioning like trac2xmcd
  which allows it to pull from existing metadata or from online sources.
* TODO build trackverify utility
  Much like flac(1)'s --verify option, this should check
  a file for correctness and, if possible, verify its output
  matches any internal hashes/checksums.
  May work recursively to check a user's entire collection.
** TODO add a .verify() method to AudioFile classes
   Returns True if the file is okay.  Raises InvalidFile if not.
   Include unit test.
   - [ ] AACAudio
   - [ ] AiffAudio
   - [X] ALACAudio
   - [ ] AuAudio
   - [X] FlacAudio
   - [ ] M4AAudio
   - [X] MP2Audio
   - [X] MP3Audio
   - [X] OggFlacAudio
   - [X] SpeexAudio
   - [X] ShortenAudio
   - [X] VorbisAudio
   - [X] WaveAudio
   - [X] WavPackAudio
** TODO add trackverify unit tests for all known verifiable problems
** DONE add trackverify man page
** DONE link trackverify man page to others
* TODO handle AIFF offset/block size in SSND chunk
* TODO Integrate WavPack
** DONE update WavPack documentation to little-endian reading order
** TODO Add WavPack decoder
*** DONE Add audiotools.decoders.WavPackDecoder object
    Must include the following attributes:
    - [X] sample_rate
    - [X] bits_per_sample
    - [X] channels
    - [X] channel_mask
    And the following methods:
    - [X] __init__
    - [X] read()
    - [X] analyze_frame()
    - [X] close()
*** DONE Add block header parsing
*** DONE Add sub-block header parsing
*** DONE Parse sub-blocks
    - [X] decorr_terms
    - [X] decorr_weights
    - [X] decorr_samples
    - [X] entropy_vars
    - [X] wv_bitstream
*** DONE Decode 1 or more blocks in read()
*** DONE Check for EOFs during decoding
*** DONE Return pcm.FrameList objects on calls to read()
*** DONE Return dict objects on calls to analyze_frame()
*** DONE Ensure different bits-per-sample work correctly
    - [X] 8 bps
    - [X] 16 bps
    - [X] 24 bps
*** DONE Ensure different number of channels work correctly
    - [X] 1 channel
    - [X] 2 channels
    - [X] 3 channels
    - [X] 4 channels
    - [X] 5 channels
    - [X] 6 channels
    - [X] 7 channels
    - [X] 8 channels
*** DONE Ensure different sample rates work correctly
    - [X] 44100Hz
    - [X] 48000Hz
    - [X] 96000Hz
    - [X] 192000Hz
*** TODO Ensure test files decode correctly
**** TODO bit_depths
     - [X] 8bit.wv
     - [ ] 12bit.wv
     - [X] 16bit.wv
     - [ ] 20bit.wv
     - [X] 24bit.wv
     - [ ] 32bit_int.wv
     - [ ] 32bit_int_p.wv
     - [ ] 32bit_float_p.wv
     - [ ] 32bit_float.wv
     (I may omit the odd bit depths in the short term)
**** TODO hybrid_bitrates
     - [ ] 24kbps.wv
     - [ ] 32kbps.wv
     - [ ] 48kbps.wv
     - [ ] 64kbps.wv
     - [ ] 128kbps.wv
     - [ ] 160kbps.wv
     - [ ] 256kbps.wv
     - [ ] 320kbps.wv
     - [ ] 384kbps.wv
     - [ ] 512kbps.wv
     - [ ] 1024kbps.wv
**** TODO hybrid_bitrates/wvc_files
     - [ ] 24kbps.wvc
     - [ ] 32kbps.wvc
     - [ ] 48kbps.wvc
     - [ ] 64kbps.wvc
     - [ ] 128kbps.wvc
     - [ ] 160kbps.wvc
     - [ ] 256kbps.wvc
     - [ ] 320kbps.wvc
     - [ ] 384kbps.wvc
     - [ ] 512kbps.wvc
     - [ ] 1024kbps.wvc
**** DONE num_channels
     - [X] mono-1.wv
     - [X] stereo-2.wv
**** TODO special_cases
     - [ ] cue_sheet.wv
     - [ ] cue_sheet.wvc
     - [X] false_stereo.wv
     - [ ] win_executable.wv
     - [X] zero_lsbs.wv
**** DONE speed_modes
     - [X] default.wv
     - [X] fast.wv
     - [X] high.wv
     - [X] vhigh.wv
*** DONE Ensure block CRC is checked
*** DONE Ensure trailing MD5 is checked, if present
** DONE Add WavPack encoder
*** DONE Add audiotools.encoders.encode_wavpack function
*** DONE Split samples into blocks based on channel count
*** DONE Write one block per block-size number of channels, per channel pair
**** DONE Calculate block CRC
**** DONE Write placeholder block header
**** DONE Determine tunable data per block
     - [X] decorrelation terms
     - [X] decorrelation deltas
     - [X] decorrelation weights
     - [X] decorrelation samples
     - [X] entropy variables (medians)
**** DONE Write sub-blocks containing tunables data
***** DONE decorrelation terms/deltas
***** DONE decorrelation weights
***** DONE decorrelation samples
***** DONE entropy variables
**** DONE Calculate bitstream values from entropy variables and PCM data
**** DONE Write bitstream sub-block
**** DONE Calculate joint-stereo
**** DONE Add channel mask sub-block for multi-channel audio
*** DONE Rewrite block headers with final "total samples" data
    Using from_pcm(), this data won't be known in advance
*** DONE Allow external RIFF WAVE header/footer
    As with Shorten, these may be passed in from outside.
*** DONE Rewrite RIFF WAVE data block header with final size
    If we're building the file with from_pcm(), this header
    will need to be built and then filled-in at finalize-time.
*** DONE Update for standalone operation
    Not necessarily to generate fully compliant files,
    but to ensure there are no memory leaks and prep
    for gprof-style optimizing.
*** DONE Generate trailing MD5
*** DONE Unify the Python and standalone encode_wavpack functions
    Much like FLAC's, making them more similar should reduce potential bugs.
*** DONE Identify/Optimize false stereo files
*** DONE Identify/Optimize wasted left bits
*** DONE Optimize memory usage
    Perform less memory allocation/freeing over the course of encoding.
*** DONE Optimize for speed
** DONE Add WavPack-specific unit tests
   - [X] test_small_files
   - [X] test_full_scale_deflection
   - [X] test_sines
   - [X] test_wasted_bps
   - [X] test_blocksizes
   - [X] test_option_variations
   - [X] test_silence
   - [X] test_noise
   - [X] test_fractional
   - [X] test_multichannel
   A combination of converted FLAC unit tests
   and stuff that's bitten me during initial implementation.
** DONE Document WavPack
*** DONE the WavPack file stream
*** DONE WavPack decoding
**** DONE WavPack sub-blocks
     - [X] decorr_terms
     - [X] decorr_weights
     - [X] decorr_samples
     - [X] entropy_vars
     - [X] wv_bitstream
**** DONE decorrelation passes
**** DONE joint stereo
**** DONE int32_info
     - [X] zeroes
     - [X] ones
     - [X] dupes
     - [X] shift
**** DONE checksum
**** DONE RIFF sub-blocks
**** DONE MD5 sub-block
**** DONE false stereo
*** DONE WavPack encoding
**** DONE false stereo
**** DONE int32_info
     for left shifting zeroes, in particular
**** DONE checksum
**** DONE joint stereo
**** DONE WavPack block header
**** DONE decorrelation passes
**** DONE WavPack sub-blocks
     - [X] decorr_terms
     - [X] decorr_weights
     - [X] decorr_samples
     - [X] entropy_vars
     - [X] extended integers
     - [X] wv_bitstream
     - [X] RIFF sub-blocks
     - [X] MD5 sub-block
**** DONE bitstream generation
*** DONE Ensure section capitalization is consistent
*** DONE Spell-check
*** DONE Verify A4 layout is correct
** DONE Test encoder/decoder against reference
   Ensure a wide range of lossless audio round-trips correctly
** DONE Remove WavePackAudio.BINARIES
** DONE Add more WavPack INVALIDFILE .verify() tests
** DONE Remove wvgain for ReplayGain application
* TODO Add percentage indicator to trackcmp/trackverify
  As an optional alternative to the running list
* TODO Add a -r/--no-results flag to trackcmp/trackverify
  Listing only the final results and not the running list
* TODO Update trackverify for multiprocess support
  I'll need some interprocess communication (probably pipes and select)
  to return the results from child processes for totals calculation.
* TODO Add optional interactive modes to utilities
  Now that Urwid is being used for editxmcd, it might be helpful
  to add optional console-based interactive modes to the other tools.
  This may improve ease-of-use (particularly discoverability
  in the case of format and quality options) without sacrificing
  scriptability or command-line power.

  Just as the command-line options are kept as consistent as possible,
  all interactive modes will also need a consistent interface.
** TODO cd2track
** TODO cd2xmcd
** TODO cdinfo
** TODO track2track
** TODO track2xmcd
** TODO trackrename
** TODO trackinfo
** TODO tracklength
** TODO track2cd
** TODO trackcmp
** TODO trackplay
** TODO tracktag
** TODO audiotools-config
** TODO trackcat
** TODO tracksplit
** TODO tracklint
** TODO trackverify
** TODO coverdump
** TODO record2track
** TODO Add unit tests for all interactive modes if possible
** TODO Document all interactive modes
* TODO Remove wavegain for applying ReplayGain to .wav files
  This should be done internally instead.
* TODO Cleanup resampler
* TODO Add a convert() method to AudioFile subclasses
  Something like:

  audiofile.convert(target_path,
                    target_class,
                    quality=None,
                    callback=None)

  so one could perform a call like:

  audiotools.open("infile.flac").convert("outfile.mp3", audiotools.MP3Audio)

  Which would perform the proper to_pcm()/from_pcm()/to_wave()/from_wave()
  calls as necessary and could be overloaded to handle specific
  conversion processes, like AIFF->Shorten with a different set of
  *IFF chunnks.
** TODO Update audio formats
** TODO Add unit tests for convert() methods
** TODO Update tools to exploit convert() method
** TODO Update documentation
